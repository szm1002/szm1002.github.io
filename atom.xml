<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr.Song&#39;s BLOG</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://songziming.com.cn/"/>
  <updated>2017-06-06T16:42:01.376Z</updated>
  <id>http://songziming.com.cn/</id>
  
  <author>
    <name>Song Ziming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>解决 img 标签间的空隙问题</title>
    <link href="http://songziming.com.cn/2017/06/07/img-gap/"/>
    <id>http://songziming.com.cn/2017/06/07/img-gap/</id>
    <published>2017-06-06T16:06:01.000Z</published>
    <updated>2017-06-06T16:42:01.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>笔者最近在开发过程中遇到一个有意思的问题。如果把一张图片，按照九宫格的方式分成9张小图，再用代码把它们拼接成一张大图的时候，水平方向和垂直方向都会出现空隙。下面来分析一下空隙产生的原因及其解决方法。</p>
<a id="more"></a>
<p>原始 HTML 代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>解决 img 标签间的空隙问题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1.jpg"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"2.jpg"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"3.jpg"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"4.jpg"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"5.jpg"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"6.jpg"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"7.jpg"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"8.jpg"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"9.jpg"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Chrome 浏览器呈现效果如下：</p>
<img src="/2017/06/07/img-gap/1.png" alt="img之间的空隙" title="img之间的空隙">
<p>可以很明显的看见，每张图片之间都产生了空隙。而水平方向和垂直方向上出现空隙的原因是不一样的，下面分别讨论。</p>
<h2 id="水平方向的空隙"><a href="#水平方向的空隙" class="headerlink" title="水平方向的空隙"></a>水平方向的空隙</h2><p>水平方向之所以出现空隙，是因为不同 img 标签之间有回车换行符/空格，它们会在页面上展示出来。所以解决办法就是把相邻的 img 标签紧挨着写不换行也不加空格，或者把回车换行符/空格注释掉。</p>
<p>修改后的代码如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>解决 img 标签间的空隙问题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 相邻的 img 标签紧挨着写 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1.jpg"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"2.jpg"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"3.jpg"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 把回车换行符注释掉 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"4.jpg"</span>&gt;</span><span class="comment">&lt;!--</span></div><div class="line"> --&gt;<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"5.jpg"</span>&gt;</span><span class="comment">&lt;!--</span></div><div class="line"> --&gt;<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"6.jpg"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"7.jpg"</span>&gt;</span><span class="comment">&lt;!--</span></div><div class="line"> --&gt;<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"8.jpg"</span>&gt;</span><span class="comment">&lt;!--</span></div><div class="line"> --&gt;<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"9.jpg"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这时 Chrome 浏览器呈现的效果图如下：</p>
<img src="/2017/06/07/img-gap/2.png" alt="解决水平方向的空隙" title="解决水平方向的空隙">
<h2 id="垂直方向的空隙"><a href="#垂直方向的空隙" class="headerlink" title="垂直方向的空隙"></a>垂直方向的空隙</h2><p>垂直方向之所以出现空隙，是因为 img 标签是行内（<code>inline</code>）元素，而行内元素的 <code>verticle-align</code> 默认是和父元素的 <code>baseline</code> 对齐的，而 <code>baseline</code> 又与父元素底边有一定距离。在本文的栗子中，具体体现为 <code>img</code> 元素与父级 <code>div</code> 元素的底边有空隙，所以视觉上图片出现了垂直方向的空隙。</p>
<blockquote>
<p>关于行内元素的对齐方式，可以参看 <a href="http://www.zhangxinxu.com/wordpress/2010/05/%E6%88%91%E5%AF%B9css-vertical-align%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3%E4%B8%8E%E8%AE%A4%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89/" title="http://www.zhangxinxu.com/wordpress/2010/05/%E6%88%91%E5%AF%B9css-vertical-align%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3%E4%B8%8E%E8%AE%A4%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">这里</a> 与 <a href="http://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/" title="http://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/" target="_blank" rel="external">这里</a> 。</p>
</blockquote>
<p>找到了原因，就能很快的解决问题了。主要解决方案有3种：</p>
<ol>
<li>设置 img 元素的对齐方式，<code>vertical-align: bottom</code>, <code>vertical-align: center</code>, <code>vertical-align: top</code>，都可以。</li>
<li>设置容器的字体大小为0，<code>div { font-size: 0 }</code>。</li>
<li>把 img 元素设置为块级元素， <code>display: block</code>。</li>
</ol>
<p>在本文的栗子中，每个 div 里还有三张图片需要水平排列，所以如果使用方案三把 img 变为块级元素后，还需要设置浮动，使用方案一及方案二则不需要特殊处理。</p>
<p>修改后的代码如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>解决 img 标签间的空隙问题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></div><div class="line">    /*解决方案1*/</div><div class="line">    .solution1 img &#123;</div><div class="line">      vertical-align: bottom;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*解决方案2*/</div><div class="line">    .solution2 &#123;</div><div class="line">      font-size: 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*解决方案3*/</div><div class="line">    .solution3 img &#123;</div><div class="line">      display: block;</div><div class="line">      float: left;</div><div class="line">    &#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"solution1"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1.jpg"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"2.jpg"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"3.jpg"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"solution2"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"4.jpg"</span>&gt;</span><span class="comment">&lt;!--</span></div><div class="line"> --&gt;<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"5.jpg"</span>&gt;</span><span class="comment">&lt;!--</span></div><div class="line"> --&gt;<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"6.jpg"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"solution3"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"7.jpg"</span>&gt;</span><span class="comment">&lt;!--</span></div><div class="line"> --&gt;<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"8.jpg"</span>&gt;</span><span class="comment">&lt;!--</span></div><div class="line"> --&gt;<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"9.jpg"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Chrome 浏览器最终呈现效果如下：</p>
<img src="/2017/06/07/img-gap/3.png" alt="解决垂直方向的空隙" title="解决垂直方向的空隙">
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>现在，就可以愉快的与九宫格形式组成的大图片愉快的玩耍啦。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;笔者最近在开发过程中遇到一个有意思的问题。如果把一张图片，按照九宫格的方式分成9张小图，再用代码把它们拼接成一张大图的时候，水平方向和垂直方向都会出现空隙。下面来分析一下空隙产生的原因及其解决方法。&lt;/p&gt;
    
    </summary>
    
      <category term="HTML/CSS" scheme="http://songziming.com.cn/categories/HTML-CSS/"/>
    
    
      <category term="img" scheme="http://songziming.com.cn/tags/img/"/>
    
      <category term="HTML" scheme="http://songziming.com.cn/tags/HTML/"/>
    
      <category term="CSS" scheme="http://songziming.com.cn/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>搭建 React + webpack + Babel 开发环境</title>
    <link href="http://songziming.com.cn/2017/05/01/react-dev-env/"/>
    <id>http://songziming.com.cn/2017/05/01/react-dev-env/</id>
    <published>2017-05-01T11:09:34.000Z</published>
    <updated>2017-05-04T04:29:19.292Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文记录了通过 <a href="https://www.npmjs.com/" title="https://www.npmjs.com/" target="_blank" rel="external">npm</a> 搭建 <a href="https://facebook.github.io/react/" title="https://facebook.github.io/react/" target="_blank" rel="external">React</a> + <a href="https://webpack.js.org/concepts/" title="https://webpack.js.org/concepts/" target="_blank" rel="external">webpack</a> + <a href="https://babeljs.io/" title="https://babeljs.io/" target="_blank" rel="external">Babel</a> 开发环境的过程，笔者在此踩了很多坑，这里谨记录正确的搭建流程，供大家参考与交流学习。</p>
<blockquote>
<p>推荐使用最新版本的 npm，且 webpack 与 Babel 均采取局部安装，而不是全局安装。</p>
</blockquote>
<a id="more"></a>
<p>首先新建一个文件夹 demo，我们将在该文件夹下配置环境：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir demo &amp;&amp; cd demo</div></pre></td></tr></table></figure>
<h2 id="安装-React"><a href="#安装-React" class="headerlink" title="安装 React"></a>安装 React</h2><p>安装 React 主要需要安装 <code>react</code> 与 <code>react-dom</code> 两个包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">npm init -y</div><div class="line"></div><div class="line">npm install --save react react-dom</div></pre></td></tr></table></figure>
<h2 id="安装-webpack"><a href="#安装-webpack" class="headerlink" title="安装 webpack"></a>安装 webpack</h2><p>安装 webpack 命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev webpack</div></pre></td></tr></table></figure>
<p>在根目录 demo 文件夹下新建一个 <code>webpack.config.js</code> 的配置文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">entry</span>: <span class="string">'./app/index.js'</span>,</div><div class="line">  <span class="attr">output</span>: &#123;</div><div class="line">    <span class="attr">filename</span>: <span class="string">'bundle.js'</span>,</div><div class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">'dist'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>通过配置文件，我们可以对 webpack 进行高度的自定义配置，具体配置方法请参考 <a href="https://webpack.js.org/configuration/" title="https://webpack.js.org/configuration/" target="_blank" rel="external">这里</a>。</p>
</blockquote>
<p>在 <code>package.json</code> 文件中 <code>scripts</code> 下添加如下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">"scripts": &#123;</div><div class="line">    "start": "webpack --config mywebpack.config.js",</div><div class="line">    "build": "webpack"</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这是推荐的最佳实践。</p>
</blockquote>
<p>通过配置 <code>build</code>，我们可以使用 <code>npm run build</code> 命令来对文件进行打包。</p>
<h2 id="安装-Babel"><a href="#安装-Babel" class="headerlink" title="安装 Babel"></a>安装 Babel</h2><p>首先安装 <code>babel-loader</code> 与 <code>babel-core</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev babel-loader babel-core</div></pre></td></tr></table></figure>
<p>为了让 Babel 能够搭配 webpack 使用，需要配置 <code>webpack.config.js</code> 文件，在 <code>module.exports</code> 中添加如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>: &#123;</div><div class="line">  <span class="attr">rules</span>: [</div><div class="line">    &#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>, <span class="attr">loader</span>: <span class="string">"babel-loader"</span> &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后安装 <code>babel-preset-env</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install babel-preset-env --save-dev</div></pre></td></tr></table></figure>
<p>我们还需要在根目录 demo 文件夹下创建 <code>.babelrc</code> 配置文件，并在里面定义：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"presets"</span>: [<span class="string">"env"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了能够在 React 中使用 JSX 与 ES6 语法，还需要安装 <code>babel-preset-react</code> 与 <code>babel-preset-es2015</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev babel-preset-react babel-preset-es2015</div></pre></td></tr></table></figure>
<p>配置 <code>.babelrc</code> 文件，在 <code>presets</code> 数组中添加 <code>react</code> 与 <code>es2015</code> 两项，文件内容变为：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"presets"</span>: [<span class="string">"env"</span>, <span class="string">"react"</span>, <span class="string">"es2015"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="配置完成"><a href="#配置完成" class="headerlink" title="配置完成"></a>配置完成</h2><p>现在，React + webpack + babel 的环境已经搭建完成，我们可以测试一下。</p>
<p>在 demo 文件夹下新建 <code>index.html</code>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>React Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"dist/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在 demo/app 目录下新建文件 index.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloExample</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello &#123;props.name&#125; !<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">HelloExample</span> <span class="attr">name</span>=<span class="string">"SongZiming"</span>/&gt;</span>,</span></div><div class="line">    document.getElementById('root')</div><div class="line">);</div></pre></td></tr></table></figure>
<p>执行打包命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run build</div></pre></td></tr></table></figure>
<p>命令行出现如下提示，说明 webpack 打包成功。</p>
<img src="/2017/05/01/react-dev-env/1.png" alt="webpack打包成功" title="webpack打包成功">
<p>用浏览器打开 index.html，显示 <code>Hello SongZiming !</code> ，测试成功！</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://facebook.github.io/react/docs/installation.html" title="https://facebook.github.io/react/docs/installation.html" target="_blank" rel="external">https://facebook.github.io/react/docs/installation.html</a></li>
<li><a href="https://webpack.js.org/guides/installation/" title="https://webpack.js.org/guides/installation/" target="_blank" rel="external">https://webpack.js.org/guides/installation/</a></li>
<li><a href="https://webpack.js.org/guides/get-started/" title="https://webpack.js.org/guides/get-started/" target="_blank" rel="external">https://webpack.js.org/guides/get-started/</a></li>
<li><a href="https://babeljs.io/docs/setup/#installation" title="https://babeljs.io/docs/setup/#installation" target="_blank" rel="external">https://babeljs.io/docs/setup/#installation</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文记录了通过 &lt;a href=&quot;https://www.npmjs.com/&quot; title=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; 搭建 &lt;a href=&quot;https://facebook.github.io/react/&quot; title=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; + &lt;a href=&quot;https://webpack.js.org/concepts/&quot; title=&quot;https://webpack.js.org/concepts/&quot;&gt;webpack&lt;/a&gt; + &lt;a href=&quot;https://babeljs.io/&quot; title=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; 开发环境的过程，笔者在此踩了很多坑，这里谨记录正确的搭建流程，供大家参考与交流学习。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;推荐使用最新版本的 npm，且 webpack 与 Babel 均采取局部安装，而不是全局安装。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="React" scheme="http://songziming.com.cn/categories/React/"/>
    
    
      <category term="React" scheme="http://songziming.com.cn/tags/React/"/>
    
      <category term="webpack" scheme="http://songziming.com.cn/tags/webpack/"/>
    
      <category term="Babel" scheme="http://songziming.com.cn/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法的 JS 实现</title>
    <link href="http://songziming.com.cn/2017/04/13/sorting-algorithm-in-js/"/>
    <id>http://songziming.com.cn/2017/04/13/sorting-algorithm-in-js/</id>
    <published>2017-04-13T04:33:52.000Z</published>
    <updated>2017-06-06T16:13:02.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>排序算法有很多，本文就最常见的冒泡排序、选择排序、插入排序、归并排序与快速排序进行一下总结，并将它们用 JavaScript 语言实现。</p>
<a id="more"></a>
<p>首先放一个总表：</p>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
<th>排序方式</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡排序</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>In-place</td>
<td>稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>In-place</td>
<td>不稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>In-place</td>
<td>稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n)</td>
<td>Out-place</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(log n)</td>
<td>In-place</td>
<td>不稳定</td>
</tr>
</tbody>
</table>
<blockquote>
<p>名词解释：</p>
<ul>
<li>n: 数据规模</li>
<li>In-place: 占用常数内存，不占用额外内存</li>
<li>Out-place: 占用额外内存</li>
<li>稳定性： 2个相等值的相对顺序在排序前后相同</li>
</ul>
</blockquote>
<h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>冒泡排序重复的走访需要排序的数列，比较任何两个相邻的项，如果前一个比第二个大，则交换它们。元素项会慢慢向上移动到正确的位置，就好像气泡升至表面一样，因此得名冒泡排序。</p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>冒泡排序的 JavaScript 代码实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> bubbleSort = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> i, j, len1, len2, tmp;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, len1 = arr.length; i &lt; len1; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>, len2 = len1 - <span class="number">1</span> - i; j &lt; len2; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</div><div class="line">                tmp = arr[j];</div><div class="line">                arr[j] = arr[j + <span class="number">1</span>];</div><div class="line">                arr[j + <span class="number">1</span>] = tmp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> arr = [<span class="number">34</span>,<span class="number">67</span>,<span class="number">33</span>,<span class="number">1</span>,<span class="number">128</span>,<span class="number">56</span>,<span class="number">8</span>,<span class="number">42</span>,<span class="number">90</span>,<span class="number">17</span>,<span class="number">256</span>];</div><div class="line">bubbleSort(arr);  <span class="comment">//[1, 8, 17, 33, 34, 42, 56, 67, 90, 128, 256]</span></div></pre></td></tr></table></figure>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>冒泡排序是最简单的排序算法，它可以原地排序，然而，它也是最没有效率的。</p>
<ul>
<li>最佳情况： T(n) = O(n)</li>
<li>最差情况： T(n) = O(n<sup>2</sup>)</li>
<li>平均情况： T(n) = O(n<sup>2</sup>)</li>
</ul>
<h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><h3 id="算法原理-1"><a href="#算法原理-1" class="headerlink" title="算法原理"></a>算法原理</h3><p>选择排序算法的大致思路是找到数组中最小的值并将其放在第一位，接着找到第二小的值并将其放在第二位。以此类推，直到所有元素排序完毕。</p>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><p>选择排序的 JavaScript 代码实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> selectionSort = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> len = arr.length,</div><div class="line">        indexMin, i, j, tmp;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</div><div class="line">        indexMin = i;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[indexMin] &gt; arr[j]) &#123;</div><div class="line">                indexMin = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (i !== indexMin) &#123;</div><div class="line">            tmp = arr[i];</div><div class="line">            arr[i] = arr[indexMin];</div><div class="line">            arr[indexMin] = tmp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> arr = [<span class="number">34</span>,<span class="number">67</span>,<span class="number">33</span>,<span class="number">1</span>,<span class="number">128</span>,<span class="number">56</span>,<span class="number">8</span>,<span class="number">42</span>,<span class="number">90</span>,<span class="number">17</span>,<span class="number">256</span>];</div><div class="line">selectionSort(arr);  <span class="comment">//[1, 8, 17, 33, 34, 42, 56, 67, 90, 128, 256]</span></div></pre></td></tr></table></figure>
<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><p>在所有的 <em>完全依靠交换</em> 去移动元素的排序方法中，选择排序属于非常好的一种。与冒泡排序一样，选择排序也是一种原址比较排序算法，但这也几乎是选择排序的唯一优点了，当空间复杂度要求较高时可以考虑选择排序，否则其实际适用场合非常罕见。</p>
<ul>
<li>最佳情况： T(n) = O(n<sup>2</sup>)</li>
<li>最差情况： T(n) = O(n<sup>2</sup>)</li>
<li>平均情况： T(n) = O(n<sup>2</sup>)</li>
</ul>
<h2 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h2><h3 id="算法原理-2"><a href="#算法原理-2" class="headerlink" title="算法原理"></a>算法原理</h3><p>插入排序将数组分成“已排序”和“未排序”两部分，一开始的时候，“已排序”的部分只有一个元素，然后将它后面一个元素从“未排序”部分插入“已排序”部分，从而“已排序”部分增加一个元素，“未排序”部分减少一个元素。以此类推，完成全部排序。</p>
<p>只要你打过扑克牌，并且尝试过将扑克牌在手中按从小到大排列，插入排序的原理就很容易理解。在摸牌时，把手上的牌当做“已排序”的部分，把还没摸的牌当做“未排序”部分，每次从桌上摸一张牌并插入到手中合适的位置，这就是插入排序的原理。</p>
<h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><p>插入排序的 JavaScript 代码实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> insertionSort = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> len = arr.length,</div><div class="line">        i, j, tmp;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++) &#123;</div><div class="line">        j = i;</div><div class="line">        tmp = arr[i];</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>] &gt; tmp) &#123;</div><div class="line">            arr[j] = arr[j - <span class="number">1</span>];</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        arr[j] = tmp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> arr = [<span class="number">34</span>,<span class="number">67</span>,<span class="number">33</span>,<span class="number">1</span>,<span class="number">128</span>,<span class="number">56</span>,<span class="number">8</span>,<span class="number">42</span>,<span class="number">90</span>,<span class="number">17</span>,<span class="number">256</span>];</div><div class="line">insertionSort(arr);  <span class="comment">//[1, 8, 17, 33, 34, 42, 56, 67, 90, 128, 256]</span></div></pre></td></tr></table></figure>
<h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><p>插入排序也是一种原地排序算法，在排序小型数组时，它比冒泡排序和选择排序都要好。</p>
<ul>
<li>最佳情况： T(n) = O(n)</li>
<li>最差情况： T(n) = O(n<sup>2</sup>)</li>
<li>平均情况： T(n) = O(n<sup>2</sup>)</li>
</ul>
<h2 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h2><h3 id="算法原理-3"><a href="#算法原理-3" class="headerlink" title="算法原理"></a>算法原理</h3><p>归并排序是一种 <em>分治</em> 算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。</p>
<p>归并排序的过程如下图所示：</p>
<img src="/2017/04/13/sorting-algorithm-in-js/mergeSort.png" alt="归并排序" title="归并排序">
<h3 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h3><p>归并排序的 JavaScript 代码实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> mergeSort = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> len = arr.length;</div><div class="line">    <span class="keyword">if</span> (len === <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> arr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>),</div><div class="line">        left = arr.slice(<span class="number">0</span>, mid),</div><div class="line">        right = arr.slice(mid);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> merge = <span class="function">(<span class="params">left, right</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> res = [],</div><div class="line">        len1 = left.length,</div><div class="line">        len2 = right.length;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (len1 &gt; <span class="number">0</span> &amp;&amp; len2 &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</div><div class="line">            res.push(left.shift());</div><div class="line">            len1--;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            res.push(right.shift());</div><div class="line">            len2--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (len1 &gt; <span class="number">0</span>) &#123;</div><div class="line">        res = res.concat(left);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (len2 &gt; <span class="number">0</span>) &#123;</div><div class="line">        res = res.concat(right);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> arr = [<span class="number">34</span>,<span class="number">67</span>,<span class="number">33</span>,<span class="number">1</span>,<span class="number">128</span>,<span class="number">56</span>,<span class="number">8</span>,<span class="number">42</span>,<span class="number">90</span>,<span class="number">17</span>,<span class="number">256</span>];</div><div class="line">mergeSort(arr);  <span class="comment">//[1, 8, 17, 33, 34, 42, 56, 67, 90, 128, 256]</span></div></pre></td></tr></table></figure>
<h3 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h3><p>归并排序是第一个可以被实际使用的排序算法，Firefox 浏览器内部实现的 <code>Array.prototype.sort()</code> 方法就采用的归并排序。归并排序是以内存空间为代价来换取时间性能的提高，它的时间复杂度始终是 <code>O(n log n)</code> ，空间复杂度是 <code>O(n)</code> 。</p>
<ul>
<li>最佳情况： T(n) = O(n log n)</li>
<li>最差情况： T(n) = O(n log n)</li>
<li>平均情况： T(n) = O(n log n)</li>
</ul>
<h2 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h2><h3 id="算法原理-4"><a href="#算法原理-4" class="headerlink" title="算法原理"></a>算法原理</h3><p>与归并排序一样，它也使用 <em>分治</em> 的思想，将原始数组分为较小的数组。但不同的是，它没有像归并排序那样将他们分割开。</p>
<h3 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h3><p>快速排序的实现过程如下：</p>
<ol>
<li>从数列中挑出一个元素（一般是中间的元素），称为 “基准”（pivot）。</li>
<li>重新排序数列，把所有比基准值小的元素放到基准前面，所有元素比基准值大的元素放到基准后面（相同的数可以放到任一边）。这个步骤被称为分区（partition）操作，在这个分区退出之后，该基准就处于数列的中间位置。</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列重复前两个步骤，直至数组已完全排序。</li>
</ol>
<p>快速排序的 JavaScript 代码实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> quickSort = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> len = arr.length;</div><div class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> arr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> pivotIndex = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>),</div><div class="line">        pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>],</div><div class="line">        left = [],</div><div class="line">        right = [];</div><div class="line"></div><div class="line">    len--;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (arr[i] &lt;= pivot) &#123;</div><div class="line">            left.push(arr[i]);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            right.push(arr[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> quickSort(left).concat(pivot, quickSort(right));</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> arr = [<span class="number">34</span>,<span class="number">67</span>,<span class="number">33</span>,<span class="number">1</span>,<span class="number">128</span>,<span class="number">56</span>,<span class="number">8</span>,<span class="number">42</span>,<span class="number">90</span>,<span class="number">17</span>,<span class="number">256</span>];</div><div class="line">quickSort(arr);  <span class="comment">//[1, 8, 17, 33, 34, 42, 56, 67, 90, 128, 256]</span></div></pre></td></tr></table></figure>
<h3 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h3><p>快速排序也许是最常用的排序算法了。Chrome 浏览器与 Microsoft Edge 浏览器内部实现的 <code>Array.prototype.sort()</code> 方法就采用的快速排序，不过它们都针对一些具体情况做出了优化，这里暂且不表。快速排序的最坏时间复杂度是 <code>O(n&lt;sup&gt;2&lt;/sup&gt;)</code> （比如顺序数列的快排），但它的平均时间复杂度是 <code>O(n log n)</code> ，且 <code>O(n log n)</code> 记号中隐含的常数因子很小，比时间复杂度稳定等于 <code>O(n log n)</code>的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序的。</p>
<ul>
<li>最佳情况： T(n) = O(n log n)</li>
<li>最差情况： T(n) = O(n<sup>2</sup>)</li>
<li>平均情况： T(n) = O(n log n)</li>
</ul>
<h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>本文的相关代码在<a href="https://github.com/szm1002/someNotes/blob/master/sorting-algorithm-in-js.js" target="_blank" rel="external">这里</a>，仅供参考。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;排序算法有很多，本文就最常见的冒泡排序、选择排序、插入排序、归并排序与快速排序进行一下总结，并将它们用 JavaScript 语言实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://songziming.com.cn/categories/Algorithms/"/>
    
    
      <category term="JavaScript" scheme="http://songziming.com.cn/tags/JavaScript/"/>
    
      <category term="排序算法" scheme="http://songziming.com.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中深复制与浅复制的实现</title>
    <link href="http://songziming.com.cn/2017/03/29/shallowCopy-and-deepCopy/"/>
    <id>http://songziming.com.cn/2017/03/29/shallowCopy-and-deepCopy/</id>
    <published>2017-03-28T16:27:50.000Z</published>
    <updated>2017-03-28T16:11:59.827Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 JavaScript 中，对于 Object 与 Array 等引用类型值的复制有深复制与浅复制的区别。简单的说，浅复制只复制一层对象的属性，而深复制则递归复制了所有层级。下面介绍一下如何实现对象的深复制与浅复制。</p>
<a id="more"></a>
<h2 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h2><p>浅复制只会将对象的各个属性依次复制，并不会进行递归复制，它很容易实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//浅复制</span></div><div class="line"><span class="keyword">const</span> shallowCopy = <span class="function"><span class="params">source</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">//检验传入的参数</span></div><div class="line">    <span class="keyword">if</span> (!source || <span class="keyword">typeof</span> source !== <span class="string">'object'</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error arguments'</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//判断参数是数组还是普通对象</span></div><div class="line">    <span class="keyword">let</span> newObj = source.constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="comment">//遍历 source 对象的属性，并赋值给 newObj 对象</span></div><div class="line">    <span class="built_in">Object</span>.keys(source).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</div><div class="line">        newObj[key] = source[key];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> newObj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>对于数组，我们还可以通过 <code>Array.prototype.slice()</code> 和 <code>Array.prototype.concat()</code> 来进行浅复制。如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr1 = [<span class="string">'szm'</span>, &#123;<span class="attr">age</span>: <span class="number">24</span>&#125;];</div><div class="line"></div><div class="line"><span class="comment">//浅复制</span></div><div class="line"><span class="keyword">let</span> arr2 = arr1.slice(); </div><div class="line"><span class="keyword">let</span> arr3 = arr1.concat(); </div><div class="line"><span class="built_in">console</span>.log(arr2);</div><div class="line"><span class="built_in">console</span>.log(arr3);  <span class="comment">// ['szm', &#123;age: 24&#125;]</span></div></pre></td></tr></table></figure>
<p>在 ES6 中，Object 类型引入了一个新的方法 <code>Object.assign()</code>，用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，所以我们可以利用它来进行对象的浅复制。如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123; </div><div class="line">    <span class="attr">name</span>: <span class="string">'szm'</span>,</div><div class="line">    <span class="attr">age</span>: <span class="number">24</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//浅复制</span></div><div class="line"><span class="keyword">let</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</div><div class="line"><span class="built_in">console</span>.log(copy);  <span class="comment">// &#123; name: 'szm', age: 24 &#125;</span></div></pre></td></tr></table></figure>
<h2 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h2><p>不同于浅复制，深复制会将对象的属性递归复制，其实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//深复制</span></div><div class="line"><span class="keyword">const</span> deepCopy = <span class="function"><span class="params">source</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">//检验传入的参数</span></div><div class="line">    <span class="keyword">if</span> (!source || <span class="keyword">typeof</span> source !== <span class="string">'object'</span> ) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error arguments'</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//判断参数是数组还是普通对象</span></div><div class="line">    <span class="keyword">let</span> newObj = source.constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="comment">//遍历 source 对象的属性，并递归赋值给 newObj 对象</span></div><div class="line">    <span class="built_in">Object</span>.keys(source).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">if</span> (source[key] &amp;&amp; <span class="keyword">typeof</span> source[key] === <span class="string">'object'</span>) &#123;</div><div class="line">            newObj[key] = source[key].constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;;</div><div class="line">            newObj[key] = deepCopy(source[key]);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            newObj[key] = source[key];</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> newObj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>除了递归，还有一种实现深复制的方式是利用 JSON 对象的 parse() 方法和 stringify() 方法，JOSN 对象中的 stringify 可以把一个 js 对象序列化为一个 JSON 字符串，parse 可以把 JSON 字符串反序列化为一个 js 对象，通过这两个方法，也可以实现对象的深复制。</p>
<p>但是，由于 JSON 对象不支持 undefined 类型与函数，所以它们在序列化时会被有意忽略。如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//利用JSON序列化实现一个深复制</span></div><div class="line"><span class="keyword">const</span> deepCopy = <span class="function"><span class="params">source</span> =&gt;</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(source));</div><div class="line"></div><div class="line"><span class="keyword">let</span> source = &#123;</div><div class="line">  <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</div><div class="line">  <span class="attr">obj</span>: &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'szm'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">func</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> target = deepCopy(source);</div><div class="line"><span class="built_in">console</span>.log(target); <span class="comment">// &#123;arr: [1,2,3], obj: &#123;name: 'szm'&#125;&#125;</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 JavaScript 中，对于 Object 与 Array 等引用类型值的复制有深复制与浅复制的区别。简单的说，浅复制只复制一层对象的属性，而深复制则递归复制了所有层级。下面介绍一下如何实现对象的深复制与浅复制。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://songziming.com.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://songziming.com.cn/tags/JavaScript/"/>
    
      <category term="深复制" scheme="http://songziming.com.cn/tags/%E6%B7%B1%E5%A4%8D%E5%88%B6/"/>
    
      <category term="浅复制" scheme="http://songziming.com.cn/tags/%E6%B5%85%E5%A4%8D%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 遍历对象属性的方法</title>
    <link href="http://songziming.com.cn/2017/03/27/traverse-object-properties/"/>
    <id>http://songziming.com.cn/2017/03/27/traverse-object-properties/</id>
    <published>2017-03-27T15:26:26.000Z</published>
    <updated>2017-03-27T15:44:18.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript 是一门面向对象的编程语言，它内置了一些可以遍历对象属性的方法，如 <code>for...in</code>, <code>Object.keys()</code>, <code>Object.getOwnPropertyNames()</code>, <code>Reflect.ownKeys()</code> 等。但这几种方法间存在一些区别，本文就来将它们对比一下。</p>
<a id="more"></a>
<h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><p><code>for...in</code> 语句是一种精确的迭代语句，可以用来枚举一个对象的所有 <strong>可枚举属性</strong>，包括对象本身的属性以及从原型链上继承的属性。如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">b</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">c</span>: <span class="number">3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//增加一个不可枚举的属性</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'d'</span>, &#123;</div><div class="line">    <span class="attr">value</span>: <span class="number">4</span>,</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//在原型链中添加一个可枚举属性</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype, <span class="string">'e'</span>, &#123;</div><div class="line">    <span class="attr">value</span>: <span class="number">5</span>,</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</div><div class="line">    <span class="built_in">console</span>.log(key);    <span class="comment">// -&gt; a, b, c, e</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意的是，由于 ECMAScript 对象的属性没有顺序，通过 <code>for...in</code> 循环输出的属性名的 <strong>顺序是不可预测的</strong>。也就是说，对象的所有属性都会被返回一次，但返回的先后顺序可能因浏览器而异。</p>
<h2 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h2><p><code>Object.keys()</code> 方法会返回一个由目标对象的 <strong>自身可枚举属性</strong> 组成的数组。它只会遍历对象自身的可枚举属性，而不会遍历到从原型链中继承的属性。如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">b</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">c</span>: <span class="number">3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//增加一个不可枚举的属性</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'d'</span>, &#123;</div><div class="line">    <span class="attr">value</span>: <span class="number">4</span>,</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//在原型链中添加一个可枚举属性</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype, <span class="string">'e'</span>, &#123;</div><div class="line">    <span class="attr">value</span>: <span class="number">5</span>,</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj));  <span class="comment">// -&gt; ["a", "b", "c"]</span></div></pre></td></tr></table></figure>
<p>通过 <code>Object.keys()</code> 返回的数组中，属性名的排列顺序和使用 <code>for...in</code> 循环遍历该对象时返回的顺序一致。</p>
<h2 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h2><p><code>Object.getOwnPropertyNames()</code> 方法会返回一个由目标对象的<strong>所有自身属性</strong>组成的数组，包括自身的不可枚举属性，但它不会遍历到原型链中继承的属性。如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">b</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">c</span>: <span class="number">3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//增加一个不可枚举的属性</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'d'</span>, &#123;</div><div class="line">    <span class="attr">value</span>: <span class="number">4</span>,</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//在原型链中添加一个可枚举属性</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype, <span class="string">'e'</span>, &#123;</div><div class="line">    <span class="attr">value</span>: <span class="number">5</span>,</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj));  <span class="comment">// -&gt; ["a", "b", "c", "d"]</span></div></pre></td></tr></table></figure>
<p>通过 <code>Object.getOwnPropertyNames()</code> 返回的数组中，可枚举属性的排列顺序也与使用 <code>for...in</code> 循环遍历该对象时返回的顺序一致，不可枚举属性的顺序未定义。</p>
<h2 id="Reflect-ownKeys"><a href="#Reflect-ownKeys" class="headerlink" title="Reflect.ownKeys()"></a>Reflect.ownKeys()</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect" title="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect" target="_blank" rel="external">Relect</a> 对象是 ES6 为了更好操作对象而提供的新 API，本文主要讨论它的一个静态方法 <code>Reflect.ownKeys()</code>。</p>
<p><code>Reflect.ownKeys()</code> 方法会返回一个由目标对象 <strong>所有自身属性</strong> 组成的数组，与 Object.getOwnPropertyNames() 相似，但前者返回的数组里还会包括目标对象自身的所有 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol" title="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank" rel="external">symbol</a> 属性键，它的返回值等同于<br> <code>Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))</code>。<br>如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">b</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">c</span>: <span class="number">3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//增加一个不可枚举的属性</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'d'</span>, &#123;</div><div class="line">    <span class="attr">value</span>: <span class="number">4</span>,</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//在原型链中添加一个可枚举属性</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype, <span class="string">'e'</span>, &#123;</div><div class="line">    <span class="attr">value</span>: <span class="number">5</span>,</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.ownKeys(obj));  <span class="comment">// -&gt; ["a", "b", "c", "d"]</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;JavaScript 是一门面向对象的编程语言，它内置了一些可以遍历对象属性的方法，如 &lt;code&gt;for...in&lt;/code&gt;, &lt;code&gt;Object.keys()&lt;/code&gt;, &lt;code&gt;Object.getOwnPropertyNames()&lt;/code&gt;, &lt;code&gt;Reflect.ownKeys()&lt;/code&gt; 等。但这几种方法间存在一些区别，本文就来将它们对比一下。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://songziming.com.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://songziming.com.cn/tags/JavaScript/"/>
    
      <category term="对象" scheme="http://songziming.com.cn/tags/%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>类数组对象转换为数组对象的几种方法</title>
    <link href="http://songziming.com.cn/2017/03/18/array-like-to-array/"/>
    <id>http://songziming.com.cn/2017/03/18/array-like-to-array/</id>
    <published>2017-03-18T05:04:23.000Z</published>
    <updated>2017-03-18T10:55:51.696Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们都知道，在 JavaScript 中，函数的参数 arguments 对象只是一个 <strong>类数组（Array-like）</strong> 对象，而不是真正的数组。那么如果我们想把它变成一个真正的数组对象，该怎么做呢？</p>
<p>下面就以 arguments 为例，总结几种类数组对象转换为数组对象的办法。</p>
<a id="more"></a>
<h2 id="原始法"><a href="#原始法" class="headerlink" title="原始法"></a>原始法</h2><p>最简单粗暴的办法，莫过于把 arguments 对象遍历，再放到一个空数组对象里。如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">listA</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> arr = [];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</div><div class="line">        arr.push(<span class="built_in">arguments</span>[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">listB</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> arr = [];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</div><div class="line">        arr[i] = <span class="built_in">arguments</span>[i];    <span class="comment">//据说比上一种方式快</span></div><div class="line">    &#125;</div><div class="line">	<span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">listC</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> arr = [];</div><div class="line">    <span class="comment">//利用 ES6 的 for...of 遍历类数组对象</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> <span class="built_in">arguments</span>) &#123;</div><div class="line">        arr.push(item);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">listA(<span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>);    <span class="comment">//[2, 6, 9, 3]</span></div><div class="line">listB(<span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>);    <span class="comment">//[2, 6, 9, 3]</span></div><div class="line">listC(<span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>);    <span class="comment">//[2, 6, 9, 3]</span></div></pre></td></tr></table></figure>
<h2 id="Array-prototype-slice-法"><a href="#Array-prototype-slice-法" class="headerlink" title="Array.prototype.slice() 法"></a>Array.prototype.slice() 法</h2><p><code>Array.prototype.slice()</code> 方法的常规用法，是将数组的一部分进行浅复制, 返回从开始到结束（不包括结束）选择的新数组对象。</p>
<p>除了上面这种用法，<code>slice()</code> 方法也可用于将一个类数组（Array-like）对象/集合转换成一个数组。我们只需将该方法绑定到需要转换的对象上。如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">listA</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">listB</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.apply(<span class="built_in">arguments</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">listA(<span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>);    <span class="comment">//[2, 6, 9, 3]</span></div><div class="line">listB(<span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>);    <span class="comment">//[2, 6, 9, 3]</span></div></pre></td></tr></table></figure>
<p>或者你也可以用 <code>[].slice</code> 来代替冗长的 <code>Array.prototype.slice</code> ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">listC</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> [].slice.call(<span class="built_in">arguments</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">listD</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> [].slice.apply(<span class="built_in">arguments</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">listC(<span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>);    <span class="comment">//[2, 6, 9, 3]</span></div><div class="line">listD(<span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>);    <span class="comment">//[2, 6, 9, 3]</span></div></pre></td></tr></table></figure>
<h2 id="Function-prototype-apply-法"><a href="#Function-prototype-apply-法" class="headerlink" title="Function.prototype.apply() 法"></a>Function.prototype.apply() 法</h2><p><code>Function.prototype.apply()</code> 方法的作用，是在指定 this 值和参数（参数以数组或类数组对象的形式存在）的情况下调用某个函数。</p>
<p>而 <code>Array()</code> 是一个构造函数，也就是 Function 对象的实例，所以它可以直接调用 <code>apply()</code> 方法，并利用该方法将类数组对象转换为数组对象。如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">list</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</div><div class="line">    <span class="comment">//相当于将 arguments 对象的值一个一个传递给 Array 函数作为参数</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">list(<span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>);    <span class="comment">//[2, 6, 9, 3]</span></div></pre></td></tr></table></figure>
<h2 id="Array-from-法"><a href="#Array-from-法" class="headerlink" title="Array.from() 法"></a>Array.from() 法</h2><p>ES6 中新增了一个 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from" title="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from" target="_blank" rel="external"><code>Array.from()</code></a> 方法，用于将 <strong>类数组对象</strong> 和 <strong>可遍历（Iterable）对象</strong> 转换为真正的数组。也就是说，在 ES6 中，有 “正统” 的办法把类数组对象转换为真正的数组对象了。如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">list</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">list(<span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>);    <span class="comment">//[2, 6, 9, 3]</span></div></pre></td></tr></table></figure>
<h2 id="扩展运算符（…）法"><a href="#扩展运算符（…）法" class="headerlink" title="扩展运算符（…）法"></a>扩展运算符（…）法</h2><p>ES6 还新增了一种运算符， <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator" title="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator" target="_blank" rel="external">扩展运算符</a>，它用三个半角句号（<code>...</code>）来表示。</p>
<p>扩展运算符可以将数组对象或类数组对象转换为用逗号分隔的参数序列。因此我们可以利用这一点来将类数组对象转换为真正的数组对象，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">listA</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> [...arguments];    <span class="comment">//变为参数序列后直接放入数组字面量中</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">listB</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Array</span>(...arguments);</div><div class="line">    <span class="comment">//变为参数序列后传递给 Array() 构造函数</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">listC</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.call(<span class="literal">null</span>, ...arguments);</div><div class="line">    <span class="comment">//变为参数序列后利用 call() 方法传递给 Array() 构造函数</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">listA(<span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>);    <span class="comment">//[2, 6, 9, 3]</span></div><div class="line">listB(<span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>);    <span class="comment">//[2, 6, 9, 3]</span></div><div class="line">listC(<span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>);    <span class="comment">//[2, 6, 9, 3]</span></div></pre></td></tr></table></figure>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上差不多就是目前笔者所知的所有将 arguments 等类数组对象转换为真正数组对象的方法了，在实际使用中，我们可以灵活选择。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们都知道，在 JavaScript 中，函数的参数 arguments 对象只是一个 &lt;strong&gt;类数组（Array-like）&lt;/strong&gt; 对象，而不是真正的数组。那么如果我们想把它变成一个真正的数组对象，该怎么做呢？&lt;/p&gt;
&lt;p&gt;下面就以 arguments 为例，总结几种类数组对象转换为数组对象的办法。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://songziming.com.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://songziming.com.cn/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://songziming.com.cn/tags/ES6/"/>
    
      <category term="数组" scheme="http://songziming.com.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的 this 关键字</title>
    <link href="http://songziming.com.cn/2017/03/13/javascript-this/"/>
    <id>http://songziming.com.cn/2017/03/13/javascript-this/</id>
    <published>2017-03-13T04:44:47.000Z</published>
    <updated>2017-03-14T15:22:43.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>this</code> 是 JavaScript 中的一个关键字，它指向一个对象。在不同场合，<code>this</code> 有不同含义，在 <em>严格模式</em> 与 <em>非严格模式</em> 之间它也有一些区别。</p>
<p>那么如何判断 this 关键字的指向呢？首先需要记住的一点是，this 所指的对象取决于它使用的时候所处的环境，而不是它定义的时候所处的环境（箭头函数除外）。下面分几种情况来分别讨论。</p>
<a id="more"></a>
<h2 id="全局上下文中的-this-值"><a href="#全局上下文中的-this-值" class="headerlink" title="全局上下文中的 this 值"></a>全局上下文中的 this 值</h2><p>在全局上下文环境中，this 总是指代 <strong>全局对象</strong> ，无论是否在严格模式下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.document === <span class="built_in">document</span>); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">this</span>.a = <span class="number">37</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 37</span></div></pre></td></tr></table></figure>
<blockquote>
<p>浏览器中的全局对象通常是 window 对象。</p>
</blockquote>
<h2 id="函数上下文中的-this-值"><a href="#函数上下文中的-this-值" class="headerlink" title="函数上下文中的 this 值"></a>函数上下文中的 this 值</h2><p>在函数内部，this 值取决于函数的调用方式。</p>
<h3 id="直接调用函数"><a href="#直接调用函数" class="headerlink" title="直接调用函数"></a>直接调用函数</h3><p>如果函数是被直接调用的，那么函数内部的 this 值在非严格模式下指向 <strong>全局对象</strong> ，在严格模式下 this 将保持它进入执行环境时的值，如果 this 未被执行的上下文环境定义，那么它会是 <code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//非严格模式</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line">f1() === <span class="built_in">window</span>; <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">//严格模式</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="meta">  "use strict"</span>; <span class="comment">// 这里是严格模式</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f2() === <span class="literal">undefined</span>; <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="对象方法中的-this"><a href="#对象方法中的-this" class="headerlink" title="对象方法中的 this"></a>对象方法中的 this</h3><p>当以对象里的方法的方式调用函数时，它们的 this 指向调用该函数的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  <span class="attr">prop</span>: <span class="number">37</span>,</div><div class="line">  <span class="attr">f</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.prop;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.f()); <span class="comment">// 37</span></div></pre></td></tr></table></figure>
<p>注意，在何处或者如何定义函数完全不影响 this 的行为，this 值是在函数调用时而不是定义时绑定。看下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">prop</span>: <span class="number">37</span>&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">independent</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.prop;</div><div class="line">&#125;</div><div class="line"></div><div class="line">o.f = independent;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.f()); <span class="comment">// 37</span></div></pre></td></tr></table></figure>
<p>我们首先定义一个函数，然后再将其添加到o.f。这样做 this 值也指向了 o 对象。</p>
<p>类似的，this 的绑定只受最靠近的成员引用的影响。在下面的这个例子中，我们把一个方法 g 当作对象 o.b 的函数调用。在这次执行期间，函数中的 this 将指向 o.b。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">o.b = &#123;</div><div class="line">  <span class="attr">g</span>: independent,</div><div class="line">  <span class="attr">prop</span>: <span class="number">42</span></div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log(o.b.g()); <span class="comment">// 42</span></div></pre></td></tr></table></figure>
<h3 id="原型链中的-this"><a href="#原型链中的-this" class="headerlink" title="原型链中的 this"></a>原型链中的 this</h3><p>同样的，定义在对象原型链中的方法的 this 值也是指向直接调用这个方法的对象，就好像是这个方法就存在于这个对象上一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  <span class="attr">f</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b; </div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.create(o);</div><div class="line">p.a = <span class="number">1</span>;</div><div class="line">p.b = <span class="number">4</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(p.f()); <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<p>这个例子中，对象 p 没有属于自己的 f 属性，它的 f 属性在它的原型对象上。但是在调用 <code>p.f()</code> 时，f() 的 this 值仍然指向了 p 对象。</p>
<h3 id="getter-与-setter-中的-this"><a href="#getter-与-setter-中的-this" class="headerlink" title="getter 与 setter 中的 this"></a>getter 与 setter 中的 this</h3><p>当一个函数作为 getter 或 setter 调用时，再次，它们都会绑定 this 到设置属性或得到属性的那个对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">modulus</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="keyword">this</span>.re * <span class="keyword">this</span>.re + <span class="keyword">this</span>.im * <span class="keyword">this</span>.im);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  <span class="attr">re</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">im</span>: <span class="number">-1</span>,</div><div class="line">  get phase()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.atan2(<span class="keyword">this</span>.im, <span class="keyword">this</span>.re);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'modulus'</span>, &#123;</div><div class="line">  <span class="attr">get</span>: modulus, <span class="attr">enumerable</span>:<span class="literal">true</span>, <span class="attr">configurable</span>:<span class="literal">true</span>&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.phase, o.modulus); <span class="comment">// -0.78 1.4142</span></div></pre></td></tr></table></figure>
<h3 id="构造函数中的-this"><a href="#构造函数中的-this" class="headerlink" title="构造函数中的 this"></a>构造函数中的 this</h3><p>当一个函数被作为一个构造函数来使用时，它的 this 会与被它创建的新实例对象绑定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = <span class="number">37</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> C();</div><div class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// 37</span></div></pre></td></tr></table></figure>
<h3 id="闭包中的-this"><a href="#闭包中的-this" class="headerlink" title="闭包中的 this"></a>闭包中的 this</h3><p>在闭包内层函数里的 this，由于闭包的函数没有直接调用对象，它会在非严格模式下指向全局对象 global/window，严格模式下为 undefined。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">num</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">getNum</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	    	<span class="keyword">return</span> <span class="keyword">this</span>.num;</div><div class="line">		&#125;)();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(obj.getNum()); <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<h3 id="事件处理函数中的-this"><a href="#事件处理函数中的-this" class="headerlink" title="事件处理函数中的 this"></a>事件处理函数中的 this</h3><h4 id="内联事件处理函数中的-this"><a href="#内联事件处理函数中的-this" class="headerlink" title="内联事件处理函数中的 this"></a>内联事件处理函数中的 this</h4><p>当代码被内联处理函数调用时，它的 this 指向监听器所在的 DOM 元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;button onclick=<span class="string">"alert(this.tagName.toLowerCase());"</span>&gt;</div><div class="line">  Show <span class="keyword">this</span>;</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>上面的 alert 会显示 button。但注意只有外层代码中的 this 是这样设置的。看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;button onclick=<span class="string">"alert((function()&#123;return this&#125;)());"</span>&gt;</div><div class="line">  Show inner <span class="keyword">this</span>;</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>在这种情况下，没有设置内部函数的 this，所以它指向 global/window 对象。</p>
<h4 id="DOM-事件处理函数中的-this"><a href="#DOM-事件处理函数中的-this" class="headerlink" title="DOM 事件处理函数中的 this"></a>DOM 事件处理函数中的 this</h4><p>当一个函数被用作事件处理函数时，它的 this 指向触发该事件的元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 被调用时，将关联的元素变成蓝色</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bluify</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span> === e.currentTarget); <span class="comment">// 总是 true</span></div><div class="line"></div><div class="line">  <span class="comment">// 当 currentTarget 和 target 是同一个对象是为 true</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span> === e.target);        </div><div class="line">  <span class="keyword">this</span>.style.backgroundColor = <span class="string">'#A5D9F3'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取文档中的所有元素的列表</span></div><div class="line"><span class="keyword">var</span> elements = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'*'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;elements.length ; i++)&#123;</div><div class="line">  elements[i].addEventListener(<span class="string">'click'</span>, bluify, <span class="literal">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="显式绑定-this-值"><a href="#显式绑定-this-值" class="headerlink" title="显式绑定 this 值"></a>显式绑定 this 值</h2><p>以上所讲的都是 this 值的默认绑定与隐式绑定，但 JavaScript 提供的绝大多数函数以及我们自<br>己创建的所有函数都可以使用 <code>call()</code> ， <code>apply()</code> 以及 ES5 引入的 <code>bind()</code> 方法来显式绑定函数的 this 指向。</p>
<h3 id="call-和-apply-方法"><a href="#call-和-apply-方法" class="headerlink" title="call() 和 apply() 方法"></a>call() 和 apply() 方法</h3><p>当一个函数的函数体中使用了 this 关键字时，通过所有函数都从 Function 对象的原型中继承的 call() 方法和 apply() 方法调用时，它的值可以绑定到一个指定的对象上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">c, d</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b + c + d;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">3</span>&#125;;</div><div class="line"></div><div class="line">add.call(o, <span class="number">5</span>, <span class="number">7</span>); <span class="comment">// 1 + 3 + 5 + 7 = 16</span></div><div class="line"></div><div class="line">add.apply(o, [<span class="number">10</span>, <span class="number">20</span>]); <span class="comment">// 1 + 3 + 10 + 20 = 34</span></div></pre></td></tr></table></figure>
<h3 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind() 方法"></a>bind() 方法</h3><p>ECMAScript 5 引入了 <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external">Function.prototype.bind</a>。调用 <code>f.bind(someObject)</code> 会创建一个与 f 具有相同函数体和作用域的函数，但是在这个新函数中，this 将永久地被绑定到了 bind 的第一个参数，无论这个函数是如何被调用的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> g = f.bind(&#123;<span class="attr">a</span>:<span class="string">"azerty"</span>&#125;);</div><div class="line"><span class="built_in">console</span>.log(g()); <span class="comment">// azerty</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">37</span>, <span class="attr">f</span>:f, <span class="attr">g</span>:g&#125;;</div><div class="line"><span class="built_in">console</span>.log(o.f(), o.g()); <span class="comment">// 37, azerty</span></div></pre></td></tr></table></figure>
<h2 id="ES6-箭头函数的-this-值"><a href="#ES6-箭头函数的-this-值" class="headerlink" title="ES6 箭头函数的 this 值"></a>ES6 箭头函数的 this 值</h2><p>ECMAScript 6 引入了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="external"><strong>箭头函数</strong></a> （<code>=&gt;</code>）的概念。</p>
<p>箭头函数内部没有自己的 this 值，它的 this 是来自它的包含环境上下文的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//非箭头函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 构造函数 Person() 定义的 `this` 就是新实例对象自己</span></div><div class="line">  <span class="keyword">this</span>.age = <span class="number">0</span>;</div><div class="line">  setInterval(<span class="function"><span class="keyword">function</span> <span class="title">growUp</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 在非严格模式下，growUp() 函数定义了其内部的 `this`</span></div><div class="line">    <span class="comment">// 为全局对象, 不同于构造函数Person()的定义的 `this`</span></div><div class="line">    <span class="keyword">this</span>.age++; </div><div class="line">  &#125;, <span class="number">1000</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line"><span class="comment">//箭头函数</span></div><div class="line"><span class="comment">//它会捕获其所在上下文的  this 值，作为自己的 this 值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.age = <span class="number">0</span>;</div><div class="line"></div><div class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">this</span>.age++; <span class="comment">// |this| 正确地指向了 person 对象</span></div><div class="line">  &#125;, <span class="number">1000</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div></pre></td></tr></table></figure>
<p>由于箭头函数的 this 已经在词法层面完成了绑定，所以通过 call() 或 apply() 方法调用一个函数时，只是传入了参数而已，对 this 并没有什么影响：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> adder = &#123;</div><div class="line">  <span class="attr">base</span> : <span class="number">1</span>,</div><div class="line"></div><div class="line">  <span class="attr">add</span> : <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="keyword">this</span>.base;</div><div class="line">    <span class="keyword">return</span> f(a);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">addThruCall</span>: <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="keyword">this</span>.base;</div><div class="line">    <span class="keyword">var</span> b = &#123;</div><div class="line">      <span class="attr">base</span> : <span class="number">2</span></div><div class="line">    &#125;;</div><div class="line">            </div><div class="line">    <span class="keyword">return</span> f.call(b, a);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(adder.add(<span class="number">1</span>));         <span class="comment">// 输出 2</span></div><div class="line"><span class="built_in">console</span>.log(adder.addThruCall(<span class="number">1</span>)); <span class="comment">// 仍然输出 2（而不是3）</span></div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单做一下总结，在判断一个 this 值的指向时，有以下几个原则：</p>
<ul>
<li>原则一： this 指向的是直接调用函数的那个对象，没有的话就指向全局对象 global/window（非严格模式）。</li>
<li>原则二： this 指向的对象就是它使用的时候（不是定义的时候）所处的环境的上下文。</li>
<li>原则三： 当 new 关键字出现时，this 指代 new 出来的那个对象。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;this&lt;/code&gt; 是 JavaScript 中的一个关键字，它指向一个对象。在不同场合，&lt;code&gt;this&lt;/code&gt; 有不同含义，在 &lt;em&gt;严格模式&lt;/em&gt; 与 &lt;em&gt;非严格模式&lt;/em&gt; 之间它也有一些区别。&lt;/p&gt;
&lt;p&gt;那么如何判断 this 关键字的指向呢？首先需要记住的一点是，this 所指的对象取决于它使用的时候所处的环境，而不是它定义的时候所处的环境（箭头函数除外）。下面分几种情况来分别讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://songziming.com.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://songziming.com.cn/tags/JavaScript/"/>
    
      <category term="this" scheme="http://songziming.com.cn/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 状态码</title>
    <link href="http://songziming.com.cn/2017/02/28/http-status-code/"/>
    <id>http://songziming.com.cn/2017/02/28/http-status-code/</id>
    <published>2017-02-28T04:29:06.000Z</published>
    <updated>2017-04-13T04:47:56.150Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>HTTP 状态码</strong>（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。它的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p>
<a id="more"></a>
<p>状态码的类别如下表所示：</p>
<table class="table table-bordered table-striped table-condensed">   <tr>      <th width="20%"></th>      <th width="40%">类别</th>      <th width="40%">原因短语</th>   </tr>   <tr>      <td>1XX</td>      <td>Informational（信息性状态码）</td>      <td>接收的请求正在处理</td>   </tr>   <tr>      <td>2XX</td>      <td>Success（成功状态码）</td>      <td>请求正常处理完毕</td>   </tr>   <tr>      <td>3XX</td>      <td>Redirection（重定向状态码）</td>      <td>需要进行附加操作以完成请求</td>   </tr>   <tr>      <td>4XX</td>      <td>Client Error（客户端错误状态码）</td>      <td>服务器无法处理请求</td>   </tr>   <tr>      <td>5XX</td>      <td>Server Error（服务器错误状态码）</td>      <td>服务器处理请求出错</td>   </tr></table>

<p>已定义的HTTP状态码多达60余种，但实际上经常使用的大概是14种。接下来，就介绍一下这些具有代表性的14个状态码。</p>
<h2 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h2><p>2XX 的响应结果表明请求被正常处理了。</p>
<h3 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h3><p><strong>200 OK</strong> 表示从客户端发来的请求在服务器端被正常处理了。</p>
<blockquote>
<p>在响应报文内，随状态码一起返回的信息会因请求方法的不同而发生改变。比如，使用 GET 方法时，对应请求资源的实体会作为响应返回；而使用 HEAD 方法时，对应请求资源的实体首部不随报文主体作为响应返回（即在响应中只返回首部，不返回实体的主体部分）。</p>
</blockquote>
<h3 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h3><p><strong>204 No Content</strong> 代表服务器接收的请求已成功处理，但在返回的响应报文中不含主体的实体部分。而且，也不允许返回任何实体的主体。</p>
<blockquote>
<p>一般在只需从客户端往服务器发送消息，而对客户端不需发送新信息内容的情况下使用。</p>
</blockquote>
<h3 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h3><p><strong>206 Partial Content</strong> 表示客户端进行了范围请求（请求一部分内容），而服务器成功执行了这部分的 GET 请求。</p>
<blockquote>
<p>响应报文中包含由 Content-Range 指定范围的实体内容。</p>
</blockquote>
<h2 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h2><p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p>
<h3 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h3><p><strong>301 Moved Permanently</strong> 代表永久重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。</p>
<blockquote>
<p>如果已经把资源对应的URI存为书签，这时应该按 Location 首部字段提示的 URI 重新保存。</p>
</blockquote>
<h3 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h3><p><strong>302 Found</strong> 代表临时重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。</p>
<blockquote>
<p>与 301 Moved Permanently 状态码相似，但 302 状态码代表资源不是被永久移动，只是临时性质的。</p>
</blockquote>
<h3 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h3><p><strong>303 See Other</strong> 表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。</p>
<blockquote>
<p>303 状态码与 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应采用 GET 方法获取资源，这点与 302 状态码有区别。</p>
</blockquote>
<h3 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h3><p><strong>304 Not Modified</strong> 表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况，直接返回 304 Not Modified （服务器端资源未改变，可直接使用客户端未过期的缓存）。304 状态码返回时，不包含任何响应的主体部分。</p>
<blockquote>
<p>304 虽然被划分在 3XX 类别中，但和重定向没有关系。</p>
</blockquote>
<h3 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h3><p><strong>307 Temporary Redirect</strong> 也代表临时重定向。该状态码与 302 Found 有相同含义。</p>
<p>尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。而 307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。</p>
<h2 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h2><p>4XX 的响应结果表明客户端是发生错误的原因所在。</p>
<h3 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h3><p><strong>400 Bad Request</strong> 表示请求报文中存在语法错误。</p>
<blockquote>
<p>当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。</p>
</blockquote>
<h3 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h3><p><strong>401 Unauthorized</strong> 表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过1次请求，则表示用户认证失败。</p>
<h3 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h3><p><strong>403 Forbidden</strong> 表明对请求资源的访问被服务器拒绝了。</p>
<blockquote>
<p>服务器端没必要给出拒绝的详细理由，但如果想作说明，可在实体的主体部分对原因进行描述，这样就能让用户看到。</p>
</blockquote>
<h3 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h3><p><strong>404 Not Found</strong> 表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。</p>
<h2 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h2><p>5XX 的响应结果表明服务器本身发生错误。</p>
<h3 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h3><p><strong>500 Internal Server Error</strong> 表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。</p>
<h3 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h3><p><strong>503 Service Unavailable</strong> 表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p>
<blockquote>
<p>如果事先得知解除以上状况需要的时间，最好写入 Retry-After 首部字段再返回给客户端。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;HTTP 状态码&lt;/strong&gt;（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。它的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。&lt;/p&gt;
    
    </summary>
    
      <category term="HTTP" scheme="http://songziming.com.cn/categories/HTTP/"/>
    
    
      <category term="HTTP状态码" scheme="http://songziming.com.cn/tags/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>前端开发者不得不知的 ES6 十大特性[转载]</title>
    <link href="http://songziming.com.cn/2017/02/17/es6-top-ten-properties/"/>
    <id>http://songziming.com.cn/2017/02/17/es6-top-ten-properties/</id>
    <published>2017-02-17T15:41:33.000Z</published>
    <updated>2017-03-09T16:20:41.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ES6（ECMAScript2015） 的出现，无疑给前端开发人员带来了新的惊喜，它包含了一些很棒的新特性，可以更加方便的实现很多复杂的操作，提高开发人员的效率。</p>
<p>本文主要针对 ES6 做一个简要介绍。 主要译自： <a href="http://webapplog.com/ES6/comment-page-1/" target="_blank" rel="external">http://webapplog.com/ES6/comment-page-1/</a>。也许你还不知道 ES6 是什么, 实际上, 它是一种新的 javascript 规范。在这个大家都很忙碌的时代，如果你想对 ES6 有一个快速的了解，那么请继续往下读，去了解当今最流行的编程语言 JavaScript 最新一代的十大特性。</p>
<a id="more"></a>
<p>以下是 ES6 排名前十的最佳特性列表（排名不分先后）：</p>
<ol>
<li>Default Parameters（默认参数） in ES6</li>
<li>Template Literals （模板文本）in ES6</li>
<li>Multi-line Strings （多行字符串）in ES6</li>
<li>Destructuring Assignment （解构赋值）in ES6</li>
<li>Enhanced Object Literals （增强的对象文本）in ES6</li>
<li>Arrow Functions （箭头函数）in ES6</li>
<li>Promises in ES6</li>
<li>Block-Scoped Constructs Let and Const（块作用域构造Let and Const）</li>
<li>Classes（类） in ES6</li>
<li>Modules（模块） in ES6</li>
</ol>
<blockquote>
<p>声明：这些列表仅是个人主观意见。它绝不是为了削弱 ES6 其它功能，这里只列出了10条比较常用的特性。</p>
</blockquote>
<p>首先回顾一下 JavaScript 的历史，不清楚历史的人，很难理解 JavaScript 为什么会这样发展。下面就是一个简单的 JavaScript 发展时间轴：</p>
<ol>
<li>1995：JavaScript 诞生，它的初始名叫 LiveScript。</li>
<li>1997：ECMAScript 标准确立。</li>
<li>1999：ES3 出现，与此同时 IE5 风靡一时。</li>
<li>2000–2005： XMLHttpRequest 又名 AJAX， 在 Outlook Web Access (2000)、Oddpost (2002)，Gmail (2004) 和 Google Maps (2005) 大受重用。</li>
<li>2009： ES5 出现，（就是我们大多数人现在使用的）例如 foreach，Object.keys，Object.create 和 JSON 标准。</li>
<li>2015：ES6/ECMAScript2015 出现。</li>
</ol>
<p>历史回顾就先到此，现让我们进入正题。</p>
<h2 id="十大特性"><a href="#十大特性" class="headerlink" title="十大特性"></a>十大特性</h2><h3 id="1-Default-Parameters（默认参数）-in-ES6"><a href="#1-Default-Parameters（默认参数）-in-ES6" class="headerlink" title="1.Default Parameters（默认参数） in ES6"></a>1.Default Parameters（默认参数） in ES6</h3><p>还记得我们以前不得不通过下面方式来定义默认参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var link = function (height, color, url) &#123;</div><div class="line">    var height = height || 50;</div><div class="line">    var color = color || &apos;red&apos;;</div><div class="line">    var url = url || &apos;http://azat.co&apos;;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一切工作都是正常的，直到参数值是0后，就有问题了，因为在 JavaScript 中，0表示 false，它是默认被 hard-coded 的值，而不能变成参数本身的值。当然，如果你非要用0作为值，我们可以忽略这一缺陷并且使用逻辑 OR 就行了！但在 ES6，我们可以直接把默认值放在函数申明里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var link = function(height = 50, color = &apos;red&apos;, url = &apos;http://azat.co&apos;) &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>顺便说一句，这个语法类似于 Ruby！</p>
<h3 id="2-Template-Literals（模板对象）-in-ES6"><a href="#2-Template-Literals（模板对象）-in-ES6" class="headerlink" title="2.Template Literals（模板对象） in ES6"></a>2.Template Literals（模板对象） in ES6</h3><p>在其它语言中，使用模板和插入值是在字符串里面输出变量的一种方式。因此，在 ES5，我们可以这样组合一个字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var name = &apos;Your name is &apos; + first + &apos; &apos; + last + &apos;.&apos;;</div><div class="line">var url = &apos;http://localhost:3000/api/messages/&apos; + id;</div></pre></td></tr></table></figure>
<p>幸运的是，在 ES6 中，我们可以使用新的语法 <code>$ {NAME}</code>，并把它放在反引号里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var name = `Your name is $&#123;first&#125; $&#123;last&#125;. `;</div><div class="line">var url = `http://localhost:3000/api/messages/$&#123;id&#125;`;</div></pre></td></tr></table></figure>
<h3 id="3-Multi-line-Strings-（多行字符串）in-ES6"><a href="#3-Multi-line-Strings-（多行字符串）in-ES6" class="headerlink" title="3.Multi-line Strings （多行字符串）in ES6"></a>3.Multi-line Strings （多行字符串）in ES6</h3><p>ES6 的多行字符串是一个非常实用的功能。在 ES5 中，我们不得不使用以下方法来表示多行字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var roadPoem = &apos;Then took the other, as just as fair,nt&apos;</div><div class="line">    + &apos;And having perhaps the better claimnt&apos;</div><div class="line">    + &apos;Because it was grassy and wanted wear,nt&apos;</div><div class="line">    + &apos;Though as for that the passing therent&apos;</div><div class="line">    + &apos;Had worn them really about the same,nt&apos;;</div><div class="line">var fourAgreements = &apos;You have the right to be you.n</div><div class="line">    You can only be you when you do your best.&apos;;</div></pre></td></tr></table></figure>
<p>然而在 ES6 中，仅仅用反引号就可以解决了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var roadPoem = `Then took the other, as just as fair,</div><div class="line">    And having perhaps the better claim</div><div class="line">    Because it was grassy and wanted wear,</div><div class="line">    Though as for that the passing there</div><div class="line">    Had worn them really about the same,`;</div><div class="line">var fourAgreements = `You have the right to be you.</div><div class="line">    You can only be you when you do your best.`;</div></pre></td></tr></table></figure>
<h3 id="4-Destructuring-Assignment-（解构赋值）in-ES6"><a href="#4-Destructuring-Assignment-（解构赋值）in-ES6" class="headerlink" title="4.Destructuring Assignment （解构赋值）in ES6"></a>4.Destructuring Assignment （解构赋值）in ES6</h3><p>解构可能是一个比较难以掌握的概念。先从一个简单的赋值讲起，其中 house 和 mouse 是 key，同时 house 和 mouse 也是一个变量，在 ES5 中是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var data = $(&apos;body&apos;).data(), // data has properties house and mouse</div><div class="line">   house = data.house,</div><div class="line">   mouse = data.mouse;</div></pre></td></tr></table></figure>
<p>以及在 node.js 中用 ES5 是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var jsonMiddleware = require(&apos;body-parser&apos;).jsonMiddleware ;</div><div class="line">var body = req.body, // body has username and password</div><div class="line">   username = body.username,</div><div class="line">   password = body.password;</div></pre></td></tr></table></figure>
<p>在 ES6，我们可以使用这些语句代替上面的 ES5 代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var &#123; house, mouse&#125; = $(&apos;body&apos;).data(); // we&apos;ll get house and mouse variables</div><div class="line">var &#123;jsonMiddleware&#125; = require(&apos;body-parser&apos;);</div><div class="line">var &#123;username, password&#125; = req.body;</div></pre></td></tr></table></figure>
<p>这个同样也适用于数组，非常赞的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var [col1, col2]  = $(&apos;.column&apos;),</div><div class="line">   [line1, line2, line3, , line5] = file.split(&apos;n&apos;);</div></pre></td></tr></table></figure>
<p>我们可能需要一些时间来习惯解构赋值语法的使用，但是它确实能给我们带来许多意外的收获。</p>
<h3 id="5-Enhanced-Object-Literals-（增强的对象字面量）in-ES6"><a href="#5-Enhanced-Object-Literals-（增强的对象字面量）in-ES6" class="headerlink" title="5.Enhanced Object Literals （增强的对象字面量）in ES6"></a>5.Enhanced Object Literals （增强的对象字面量）in ES6</h3><p>使用对象文本可以做许多让人意想不到的事情！通过ES6，我们可以把ES5中的JSON变得更加接近于一个类。</p>
<p>下面是一个典型ES5对象文本，里面有一些方法和属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var serviceBase = &#123;port: 3000, url: &apos;azat.co&apos;&#125;,</div><div class="line">    getAccounts = function()&#123;return [1,2,3]&#125;;</div><div class="line">var accountServiceES5 = &#123;</div><div class="line">  port: serviceBase.port,</div><div class="line">  url: serviceBase.url,</div><div class="line">  getAccounts: getAccounts,</div><div class="line">   toString: function() &#123;</div><div class="line">      return JSON.stringify(this.valueOf());</div><div class="line">  &#125;,</div><div class="line">  getUrl: function() &#123;return &quot;http://&quot; + this.url + &apos;:&apos; + this.port&#125;,</div><div class="line">  valueOf_1_2_3: getAccounts()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们想让它更有意思，我们可以用 Object.create 从 serviceBase 继承原型的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var accountServiceES5ObjectCreate = Object.create(serviceBase)</div><div class="line">var accountServiceES5ObjectCreate = &#123;</div><div class="line">  getAccounts: getAccounts,</div><div class="line">  toString: function() &#123;</div><div class="line">    return JSON.stringify(this.valueOf());</div><div class="line">  &#125;,</div><div class="line">  getUrl: function() &#123;return &quot;http://&quot; + this.url + &apos;:&apos; + this.port&#125;,</div><div class="line">  valueOf_1_2_3: getAccounts()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们知道，accountServiceES5ObjectCreate 和 accountServiceES5 并不是完全一致的，因为一个对象 (accountServiceES5) 在 <strong>proto</strong> 对象中将有下面这些属性：</p>
<img src="/2017/02/17/es6-top-ten-properties/1.png" alt="1.png" title="">
<p>为了方便举例，我们将考虑它们的相似处。所以在 ES6 的对象文本中，既可以直接分配 getAccounts: getAccounts,也可以只需用一个 getAccounts，此外，我们在这里通过 <strong>proto</strong> （并不是通过 ’proto’）设置属性，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var serviceBase = &#123;port: 3000, url: &apos;azat.co&apos;&#125;,</div><div class="line">getAccounts = function()&#123;return [1,2,3]&#125;;</div><div class="line">var accountService = &#123;</div><div class="line">    __proto__: serviceBase,</div><div class="line">    getAccounts,</div></pre></td></tr></table></figure>
<p>另外，我们可以调用 super 防范，以及使用动态 key 值 (valueOf_1_2_3):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">    toString() &#123;</div><div class="line">     return JSON.stringify((super.valueOf()));</div><div class="line">    &#125;,</div><div class="line">    getUrl() &#123;return &quot;http://&quot; + this.url + &apos;:&apos; + this.port&#125;,</div><div class="line">    [ &apos;valueOf_&apos; + getAccounts().join(&apos;_&apos;) ]: getAccounts()</div><div class="line">&#125;;</div><div class="line">console.log(accountService)</div></pre></td></tr></table></figure>
<img src="/2017/02/17/es6-top-ten-properties/3.png" alt="3.png" title="">
<p>ES6 对象文本是一个很大的进步对于旧版的对象文本来说。</p>
<h3 id="6-Arrow-Functions-（箭头函数）-in-ES6"><a href="#6-Arrow-Functions-（箭头函数）-in-ES6" class="headerlink" title="6.Arrow Functions （箭头函数） in ES6"></a>6.Arrow Functions （箭头函数） in ES6</h3><p>这是我迫不及待想讲的一个特征，CoffeeScript 就是因为它丰富的箭头函数让很多开发者喜爱。在 ES6 中，也有了丰富的箭头函数。这些丰富的箭头是令人惊讶的因为它们将使许多操作变成现实，比如，以前我们使用闭包，this 总是预期之外地产生改变，而箭头函数的迷人之处在于，现在你的 this 可以按照你的预期使用了，身处箭头函数里面，this 还是原来的 this。</p>
<p>有了箭头函数在 ES6 中， 我们就不必用 that = this 或 self =  this 或 _this = this 或 .bind(this)。例如，下面的代码用 ES5 就不是很优雅：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var _this = this;</div><div class="line">$(&apos;.btn&apos;).click(function(event)&#123;</div><div class="line">  _this.sendData();</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>在 ES6 中就不需要用 _this = this：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(&apos;.btn&apos;).click((event) =&gt;&#123;</div><div class="line">  this.sendData();</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>不幸的是，ES6 委员会决定，以前的 function 的传递方式也是一个很好的方案，所以它们仍然保留了以前的功能。</p>
<p>下面这是一个另外的例子，我们通过 call 传递文本给 logUpperCase() 函数在 ES5 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var logUpperCase = function() &#123;</div><div class="line">  var _this = this;</div><div class="line"> </div><div class="line">  this.string = this.string.toUpperCase();</div><div class="line">  return function () &#123;</div><div class="line">    return console.log(_this.string);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">logUpperCase.call(&#123; string: &apos;ES6 rocks&apos; &#125;)();</div></pre></td></tr></table></figure>
<p>而在 ES6，我们并不需要用 _this 浪费时间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var logUpperCase = function() &#123;</div><div class="line">  this.string = this.string.toUpperCase();</div><div class="line">  return () =&gt; console.log(this.string);</div><div class="line">&#125;</div><div class="line">logUpperCase.call(&#123; string: &apos;ES6 rocks&apos; &#125;)();</div></pre></td></tr></table></figure>
<p>请注意，只要你愿意，在 ES6 中 <code>=&gt;</code> 可以混合和匹配老的函数一起使用。当在一行代码中用了箭头函数，它就变成了一个表达式。它将暗地里返回单个语句的结果。如果你超过了一行，将需要明确使用 return。</p>
<p>这是用 ES5 代码创建一个消息数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var ids = [&apos;5632953c4e345e145fdf2df8&apos;,&apos;563295464e345e145fdf2df9&apos;];</div><div class="line">var messages = ids.map(function (value) &#123;</div><div class="line">  return &quot;ID is &quot; + value; // explicit return</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>用 ES6 是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var ids = [&apos;5632953c4e345e145fdf2df8&apos;,&apos;563295464e345e145fdf2df9&apos;];</div><div class="line">var messages = ids.map(value =&gt; `ID is $&#123;value&#125;`); // implicit return</div></pre></td></tr></table></figure>
<p>请注意，这里用了字符串模板。</p>
<p>在箭头函数中，对于单个参数，括号()是可选的，但当你超过一个参数的时候你就需要他们。</p>
<p>在 ES5 代码有明确的返回功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var ids = [&apos;5632953c4e345e145fdf2df8&apos;, &apos;563295464e345e145fdf2df9&apos;];</div><div class="line">var messages = ids.map(function (value, index, list) &#123;</div><div class="line">  return &apos;ID of &apos; + index + &apos; element is &apos; + value + &apos; &apos;; // explicit return</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在 ES6 中有更加严谨的版本，参数需要被包含在括号里并且它是隐式的返回：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var ids = [&apos;5632953c4e345e145fdf2df8&apos;,&apos;563295464e345e145fdf2df9&apos;];</div><div class="line">var messages = ids.map((value, index, list) =&gt; `ID of $&#123;index&#125; element is $&#123;value&#125; `); // implicit return</div></pre></td></tr></table></figure>
<h3 id="7-Promises-in-ES6"><a href="#7-Promises-in-ES6" class="headerlink" title="7. Promises in ES6"></a>7. Promises in ES6</h3><p>Promises 是一个有争议的话题。因此有许多略微不同的 promise 实现语法。Q，bluebird，deferred.js，vow, avow, jquery 一些可以列出名字的。也有人说我们不需要 promises，仅仅使用异步，生成器，回调等就够了。但令人高兴的是，在 ES6 中有标准的 Promise 实现。</p>
<p>下面是一个简单的用 setTimeout() 实现的异步延迟加载函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setTimeout(function()&#123;</div><div class="line">  console.log(&apos;Yay!&apos;);</div><div class="line">&#125;, 1000);</div></pre></td></tr></table></figure>
<p>在 ES6 中，我们可以用 promise 重写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var wait1000 =  new Promise(function(resolve, reject) &#123;</div><div class="line">  setTimeout(resolve, 1000);</div><div class="line">&#125;).then(function() &#123;</div><div class="line">  console.log(&apos;Yay!&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>或者用ES6的箭头函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var wait1000 =  new Promise((resolve, reject)=&gt; &#123;</div><div class="line">  setTimeout(resolve, 1000);</div><div class="line">&#125;).then(()=&gt; &#123;</div><div class="line">  console.log(&apos;Yay!&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>到目前为止，代码的行数从三行增加到五行，并没有任何明显的好处。确实，如果我们有更多的嵌套逻辑在 setTimeout() 回调函数中，我们将发现更多好处：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">setTimeout(function()&#123;</div><div class="line">  console.log(&apos;Yay!&apos;);</div><div class="line">  setTimeout(function()&#123;</div><div class="line">    console.log(&apos;Wheeyee!&apos;);</div><div class="line">  &#125;, 1000)</div><div class="line">&#125;, 1000);</div></pre></td></tr></table></figure>
<p>在 ES6 中我们可以用 promises 重写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var wait1000 =  ()=&gt; new Promise((resolve, reject)=&gt; &#123;setTimeout(resolve, 1000)&#125;);</div><div class="line">wait1000()</div><div class="line">    .then(function() &#123;</div><div class="line">        console.log(&apos;Yay!&apos;)</div><div class="line">        return wait1000()</div><div class="line">    &#125;)</div><div class="line">    .then(function() &#123;</div><div class="line">        console.log(&apos;Wheeyee!&apos;)</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>还是不确信 Promises 比普通回调更好？其实我也不确信，我认为一旦你有回调的想法，那么就没有必要额外增加 promises 的复杂性。</p>
<p>虽然，ES6 有让人崇拜的Promises。Promises 是一个有利有弊的回调但是确实是一个好的特性，更多详细的信息关于 promise: <a href="http://jamesknelson.com/grokking-es6-promises-the-four-functions-you-need-to-avoid-callback-hell" target="_blank" rel="external">Introduction to ES6 Promises</a>.</p>
<h3 id="8-Block-Scoped-Constructs-Let-and-Const（块作用域和构造let和const）"><a href="#8-Block-Scoped-Constructs-Let-and-Const（块作用域和构造let和const）" class="headerlink" title="8.Block-Scoped Constructs Let and Const（块作用域和构造let和const）"></a>8.Block-Scoped Constructs Let and Const（块作用域和构造let和const）</h3><p>在 ES6 代码中，你可能已经看到那熟悉的身影 let。在 ES6 里 let 并不是一个花俏的特性，它是更复杂的。let 是一种新的变量申明方式，它允许你把变量作用域控制在块级里面。我们用大括号定义代码块，在 ES5 中，块级作用域起不了任何作用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function calculateTotalAmount (vip) &#123;</div><div class="line">  var amount = 0;</div><div class="line">  if (vip) &#123;</div><div class="line">    var amount = 1;</div><div class="line">  &#125;</div><div class="line">  &#123; // more crazy blocks!</div><div class="line">    var amount = 100;</div><div class="line">    &#123;</div><div class="line">      var amount = 1000;</div><div class="line">    &#125;</div><div class="line">  &#125;  </div><div class="line">  return amount;</div><div class="line">&#125;</div><div class="line">console.log(calculateTotalAmount(true));</div></pre></td></tr></table></figure>
<p>结果将返回1000，这真是一个 bug。在 ES6 中，我们用 let 限制块级作用域。而 var 是限制函数作用域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function calculateTotalAmount (vip) &#123;</div><div class="line">  var amount = 0; // probably should also be let, but you can mix var and let</div><div class="line">  if (vip) &#123;</div><div class="line">    let amount = 1; // first amount is still 0</div><div class="line">  &#125; </div><div class="line">  &#123; // more crazy blocks!</div><div class="line">    let amount = 100; // first amount is still 0</div><div class="line">    &#123;</div><div class="line">      let amount = 1000; // first amount is still 0</div><div class="line">    &#125;</div><div class="line">  &#125;  </div><div class="line">  return amount;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">console.log(calculateTotalAmount(true));</div></pre></td></tr></table></figure>
<p>这个结果将会是0，因为块作用域中有了 let。如果 （amount=1）.那么这个表达式将返回1。谈到 const，就更加容易了；它就是一个不变量，也是块级作用域就像 let 一样。下面是一个演示，这里有一堆常量，它们互不影响，因为它们属于不同的块级作用域:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function calculateTotalAmount (vip) &#123;</div><div class="line">  const amount = 0;  </div><div class="line">  if (vip) &#123;</div><div class="line">    const amount = 1;</div><div class="line">  &#125; </div><div class="line">  &#123; // more crazy blocks!</div><div class="line">    const amount = 100 ;</div><div class="line">    &#123;</div><div class="line">      const amount = 1000;</div><div class="line">    &#125;</div><div class="line">  &#125;  </div><div class="line">  return amount;</div><div class="line">&#125;</div><div class="line">console.log(calculateTotalAmount(true));</div></pre></td></tr></table></figure>
<p>从我个人看来，let 和 const 使这个语言变复杂了。没有它们的话，我们只需考虑一种方式，现在有许多种场景需要考虑。</p>
<h3 id="9-Classes-（类）in-ES6"><a href="#9-Classes-（类）in-ES6" class="headerlink" title="9.Classes （类）in ES6"></a>9.Classes （类）in ES6</h3><p>如果你喜欢面向对象编程 （OOP），那么你将喜爱这个特性。以后写一个类和继承将变得跟在 facebook 上写一个评论那么容易。</p>
<p>类的创建和使用真是一件令人头疼的事情在过去的 ES5 中，因为没有一个关键字 class （它被保留，但是什么也不能做）。在此之上，大量的继承模型像 pseudo classical, classical, functional 更加增加了混乱，JavaScript 之间的宗教战争只会更加火上浇油。</p>
<p>用 ES5 写一个类，有很多种方法，这里就先不说了。现在就来看看如何用 ES6 写一个类吧。ES6 没有用函数, 而是使用原型实现类。我们创建一个类 baseModel ，并且在这个类里定义了一个 constructor 和一个  getName() 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class baseModel &#123;</div><div class="line">  constructor(options, data) &#123; // class constructor，node.js 5.6暂时不支持options = &#123;&#125;, data = []这样传参</div><div class="line">    this.name = &apos;Base&apos;;</div><div class="line">    this.url = &apos;http://azat.co/api&apos;;</div><div class="line">    this.data = data;</div><div class="line">    this.options = options;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">    getName() &#123; // class method</div><div class="line">        console.log(`Class name: $&#123;this.name&#125;`);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意我们对 options 和 data 使用了默认参数值。此外方法名也不需要加 function 关键字，而且冒号 (：) 也不需要了。另外一个大的区别就是你不需要分配属性 this。现在设置一个属性的值，只需简单的在构造函数中分配。</p>
<p>AccountModel 从类 baseModel 中继承而来:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class AccountModel extends baseModel &#123;</div><div class="line">    constructor(options, data) &#123;</div></pre></td></tr></table></figure>
<p>为了调用父级构造函数，可以毫不费力的唤起 super() 用参数传递：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">       super(&#123;private: true&#125;, [&apos;32113123123&apos;, &apos;524214691&apos;]); //call the parent method with super</div><div class="line">   this.name = &apos;Account Model&apos;;</div><div class="line">   this.url +=&apos;/accounts/&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你想做些更好玩的，你可以把 accountData 设置成一个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    get accountsData() &#123; //calculated attribute getter</div><div class="line">    // ... make XHR</div><div class="line">        return this.data;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么，你如何调用他们呢？它是非常容易的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let accounts = new AccountModel(5);</div><div class="line">accounts.getName();</div><div class="line">console.log(&apos;Data is %s&apos;, accounts.accountsData);</div></pre></td></tr></table></figure>
<p>结果令人惊讶，输出是：</p>
<p>Class name: Account Model<br>Data is  32113123123,524214691</p>
<h3 id="10-Modules-（模块）in-ES6"><a href="#10-Modules-（模块）in-ES6" class="headerlink" title="10.Modules （模块）in ES6"></a>10.Modules （模块）in ES6</h3><p>众所周知，在 ES6 以前 JavaScript 并不支持本地的模块。人们想出了 AMD，RequireJS，CommonJS 以及其它解决方法。现在 ES6 中可以用模块 import 和 export 操作了。 </p>
<p>在 ES5 中，你可以在 <code>script</code> 标签中直接写可以运行的代码 （简称 IIFE），或者一些库像 AMD。然而在 ES6 中，你可以用 export 导入你的类。下面举个例子，在 ES5 中, module.js 有 port 变量和 getAccounts 方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  port: 3000,</div><div class="line">  getAccounts: function() &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 ES5 中，main.js 需要依赖 require(‘module’)  导入 module.js：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var service = require(&apos;module.js&apos;);</div><div class="line">console.log(service.port); // 3000</div></pre></td></tr></table></figure>
<p>但在 ES6 中，我们将用 export and import。例如，这是我们用 ES6 写的 module.js 文件库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">export var port = 3000;</div><div class="line">export function getAccounts(url) &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果用 ES6 来导入到文件 main.js 中，我们需用 import {name} from ‘my-module’ 语法，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import &#123;port, getAccounts&#125; from &apos;module&apos;;</div><div class="line">console.log(port); // 3000</div></pre></td></tr></table></figure>
<p>或者我们可以在 main.js 中把整个模块导入, 并命名为 service：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import * as service from &apos;module&apos;;</div><div class="line">console.log(service.port); // 3000</div></pre></td></tr></table></figure>
<p>从我个人角度来说，我觉得 ES6 模块是让人困惑的。但可以肯定的事，它们使语言更加灵活了。</p>
<p>并不是所有的浏览器都支持 ES6 模块，所以你需要使用一些像 jspm 去支持 ES6 模块。</p>
<p>更多的信息和例子关于 ES6 模块，请看 <a href="http://exploringjs.com/es6/ch_modules.html" target="_blank" rel="external">this text</a>。不管怎样，请写模块化的 JavaScript。</p>
<h2 id="如何使用-ES6-Babel"><a href="#如何使用-ES6-Babel" class="headerlink" title="如何使用 ES6 (Babel)"></a>如何使用 ES6 (Babel)</h2><p>ES6 已经敲定，但并不是所有的浏览器都完全支持，详见：<a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="external">http://kangax.github.io/compat-table/es6/</a>。要使用 ES6，需要一个编译器例如： babel。你可以把它作为一个独立的工具使用，也可以把它放在构建中。 grunt，gulp 和 webpack 中都有可以支持 babel 的插件。</p>
<img src="/2017/02/17/es6-top-ten-properties/2.png" alt="2.png" title="">
<p>这是一个 gulp 案列，安装 gulp-babel 插件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save-dev gulp-babel</div></pre></td></tr></table></figure>
<p>在 gulpfile.js 中，定义一个任务 build，放入 src/app.js，并且编译它进入构建文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var gulp = require(&apos;gulp&apos;),</div><div class="line">  babel = require(&apos;gulp-babel&apos;);</div><div class="line">gulp.task(&apos;build&apos;, function () &#123;</div><div class="line">  return gulp.src(&apos;src/app.js&apos;)</div><div class="line">    .pipe(babel())</div><div class="line">    .pipe(gulp.dest(&apos;build&apos;));</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="Node-js-and-ES6"><a href="#Node-js-and-ES6" class="headerlink" title="Node.js and ES6"></a>Node.js and ES6</h2><p>在 Node.js 中，你可以用构建工具或者独立的 Babel 模块 babel-core 来编译你的 Node.js 文件。安装如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save-dev babel-core</div></pre></td></tr></table></figure>
<p>然后在 Node.js 中，你可以调用这个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">require(&quot;babel-core&quot;).transform(ES5Code, options);</div></pre></td></tr></table></figure>
<h2 id="ES6总结"><a href="#ES6总结" class="headerlink" title="ES6总结"></a>ES6总结</h2><p>这里还有许多 ES6 的其它特性你可能会使用到，排名不分先后：</p>
<ol>
<li>全新的 Math, Number, String, Array 和 Object 方法</li>
<li>二进制和八进制数据类型</li>
<li>默认参数不定参数扩展运算符</li>
<li>Symbols 符号</li>
<li>tail 调用</li>
<li>Generators (生成器)</li>
<li>New data structures like Map and Set (新的数据构造对像MAP和set)</li>
</ol>
<h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><ol>
<li><a href="https://github.com/azat-co/cheatsheets/tree/master/es6" target="_blank" rel="external">ES6 Cheatsheet</a> (<a href="https://gum.co/LDwVU/git-1CC81D40" target="_blank" rel="external">FREE PDF</a>)</li>
<li><a href="http://webapplog.com/ES6/comment-page-1/" target="_blank" rel="external">http://webapplog.com/ES6/comment-page-1/</a></li>
<li><a href="https://leanpub.com/understandinges6" target="_blank" rel="external">Understanding ECMAScript 6 by Nicolas Zakas book</a></li>
<li><a href="http://ES6-features.org/#DateTimeFormatting" target="_blank" rel="external">http://ES6-features.org/#DateTimeFormatting</a></li>
<li>IIFE：立刻运行的函数表达式</li>
</ol>
<blockquote>
<p>转载自AlloyTeam： <a href="http://www.alloyteam.com/2016/03/es6-front-end-developers-will-have-to-know-the-top-ten-properties/" target="_blank">http://www.alloyteam.com/2016/03/es6-front-end-developers-will-have-to-know-the-top-ten-properties/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;ES6（ECMAScript2015） 的出现，无疑给前端开发人员带来了新的惊喜，它包含了一些很棒的新特性，可以更加方便的实现很多复杂的操作，提高开发人员的效率。&lt;/p&gt;
&lt;p&gt;本文主要针对 ES6 做一个简要介绍。 主要译自： &lt;a href=&quot;http://webapplog.com/ES6/comment-page-1/&quot;&gt;http://webapplog.com/ES6/comment-page-1/&lt;/a&gt;。也许你还不知道 ES6 是什么, 实际上, 它是一种新的 javascript 规范。在这个大家都很忙碌的时代，如果你想对 ES6 有一个快速的了解，那么请继续往下读，去了解当今最流行的编程语言 JavaScript 最新一代的十大特性。&lt;/p&gt;
    
    </summary>
    
      <category term="ES6" scheme="http://songziming.com.cn/categories/ES6/"/>
    
    
      <category term="ES6" scheme="http://songziming.com.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>30分钟掌握ES6/ES2015核心内容[转载]</title>
    <link href="http://songziming.com.cn/2017/02/17/es6-core/"/>
    <id>http://songziming.com.cn/2017/02/17/es6-core/</id>
    <published>2017-02-17T15:27:29.000Z</published>
    <updated>2017-03-09T16:19:40.318Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。</p>
<p>也就是说，ES6就是ES2015。</p>
<p>虽然目前并不是所有浏览器都能兼容ES6全部特性，但越来越多的程序员在实际项目当中已经开始使用ES6了。所以就算你现在不打算使用ES6，但为了看懂别人的你也该懂点ES6的语法了…</p>
<a id="more"></a>
<p>在我们正式讲解ES6语法之前，我们得先了解下Babel。<br><a href="https://babeljs.io/" title="Babel" target="_blank" rel="external">Babel</a></p>
<p>Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。大家可以选择自己习惯的工具来使用使用Babel，具体过程可直接在Babel官网查看：</p>
<img src="/2017/02/17/es6-core/1.png" alt="https://babeljs.io/docs/setup/" title="https://babeljs.io/docs/setup/">
<h2 id="最常用的ES6特性"><a href="#最常用的ES6特性" class="headerlink" title="最常用的ES6特性"></a>最常用的ES6特性</h2><p><code>let, const, class, extends, super, arrow functions, template string, destructuring, default, rest arguments</code></p>
<p>这些是ES6最常用的几个语法，基本上学会它们，我们就可以走遍天下都不怕啦！我会用最通俗易懂的语言和例子来讲解它们，保证一看就懂，一学就会。</p>
<h3 id="let-const"><a href="#let-const" class="headerlink" title="let, const"></a>let, const</h3><p>这两个的用途与var类似，都是用来声明变量的，但在实际运用中他俩都有各自的特殊用途。<br>首先来看下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var name = &apos;zach&apos;</div><div class="line"></div><div class="line">while (true) &#123;</div><div class="line">    var name = &apos;obama&apos;</div><div class="line">    console.log(name)  //obama</div><div class="line">    break</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(name)  //obama</div></pre></td></tr></table></figure>
<p>使用 <code>var</code> 两次输出都是 obama，这是因为ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景就是你现在看到的内层变量覆盖外层变量。而 <code>let</code> 则实际上为 JavaScript 新增了块级作用域。用它所声明的变量，只在 <code>let</code> 命令所在的代码块内有效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let name = &apos;zach&apos;</div><div class="line"></div><div class="line">while (true) &#123;</div><div class="line">    let name = &apos;obama&apos;</div><div class="line">    console.log(name)  //obama</div><div class="line">    break</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(name)  //zach</div></pre></td></tr></table></figure>
<p>另外一个 <code>var</code> 带来的不合理场景就是用来计数的循环变量泄露为全局变量，看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = [];</div><div class="line">for (var i = 0; i &lt; 10; i++) &#123;</div><div class="line">  a[i] = function () &#123;</div><div class="line">    console.log(i);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">a[6](); // 10</div></pre></td></tr></table></figure>
<p>上面代码中，变量 i 是 <code>var</code> 声明的，在全局范围内都有效。所以每一次循环，新的 i 值都会覆盖旧值，导致最后输出的是最后一轮的i的值。而使用 <code>let</code> 则不会出现这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = [];</div><div class="line">for (let i = 0; i &lt; 10; i++) &#123;</div><div class="line">  a[i] = function () &#123;</div><div class="line">    console.log(i);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">a[6](); // 6</div></pre></td></tr></table></figure>
<p>再来看一个更常见的例子，了解下如果不用 ES6，而用闭包如何解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var clickBoxs = document.querySelectorAll(&apos;.clickBox&apos;)</div><div class="line">for (var i = 0; i &lt; clickBoxs.length; i++)&#123;</div><div class="line">    clickBoxs[i].onclick = function()&#123;</div><div class="line">        console.log(i)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们本来希望的是点击不同的 clickBox，显示不同的 i，但事实是无论我们点击哪个 clickBox，输出的都是5。下面我们来看下，如何用闭包搞定它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function iteratorFactory(i)&#123;</div><div class="line">    var onclick = function(e)&#123;</div><div class="line">        console.log(i)</div><div class="line">    &#125;</div><div class="line">    return onclick;</div><div class="line">&#125;</div><div class="line">var clickBoxs = document.querySelectorAll(&apos;.clickBox&apos;)</div><div class="line">for (var i = 0; i &lt; clickBoxs.length; i++)&#123;</div><div class="line">    clickBoxs[i].onclick = iteratorFactory(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>const</code> 也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const PI = Math.PI</div><div class="line"></div><div class="line">PI = 23 //Module build failed: SyntaxError: /es6/app.js: &quot;PI&quot; is read-only</div></pre></td></tr></table></figure>
<p>当我们尝试去改变用 <code>const</code> 声明的常量时，浏览器就会报错。</p>
<p><code>const</code> 有一个很好的应用场景，就是当我们引用第三方库的时声明的变量，用 <code>const</code> 来声明可以避免未来不小心重命名而导致出现 bug：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const monent = require(&apos;moment&apos;)</div></pre></td></tr></table></figure>
<h3 id="class-extends-super"><a href="#class-extends-super" class="headerlink" title="class, extends, super"></a>class, extends, super</h3><p>这三个特性涉及了 ES5 中最令人头疼的的几个部分：原型、构造函数，继承…你还在为它们复杂难懂的语法而烦恼吗？你还在为指针到底指向哪里而纠结万分吗？</p>
<p>有了ES6我们不再烦恼！</p>
<p>ES6提供了更接近传统语言的写法，引入了 Class（类） 这个概念。新的 class 写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class Animal &#123;</div><div class="line">    constructor()&#123;</div><div class="line">        this.type = &apos;animal&apos;</div><div class="line">    &#125;</div><div class="line">    says(say)&#123;</div><div class="line">        console.log(this.type + &apos; says &apos; + say)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let animal = new Animal()</div><div class="line">animal.says(&apos;hello&apos;) //animal says hello</div><div class="line"></div><div class="line">class Cat extends Animal &#123;</div><div class="line">    constructor()&#123;</div><div class="line">        super()</div><div class="line">        this.type = &apos;cat&apos;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let cat = new Cat()</div><div class="line">cat.says(&apos;hello&apos;) //cat says hello</div></pre></td></tr></table></figure>
<p>上面代码首先用 <code>class</code> 定义了一个“类”，可以看到里面有一个 <code>constructor</code> 方法，这就是构造方法，而this关键字则代表实例对象。简单地说，<code>constructor</code> 内定义的方法和属性是实例对象自己的，而 <code>constructor</code> 外定义的方法和属性则是所有实力对象可以共享的。</p>
<p>Class 之间可以通过 <code>extends</code> 关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。上面定义了一个 Cat 类，该类通过 <code>extends</code> 关键字，继承了 Animal 类的所有属性和方法。</p>
<p><code>super</code> 关键字，它指代父类的实例（即父类的 this 对象）。子类必须在 <code>constructor</code> 方法中调用 <code>super</code> 方法，否则新建实例时会报错。这是因为子类没有自己的 <code>this</code> 对象，而是继承父类的 <code>this</code> 对象，然后对其进行加工。如果不调用 <code>super</code> 方法，子类就得不到 <code>this</code> 对象。</p>
<p>ES6 的继承机制，实质是先创造父类的实例对象 this （所以必须先调用 super 方法），然后再用子类的构造函数修改 this。</p>
<p>P.S 如果你写 react 的话，就会发现以上三个东西在最新版 React 中出现得很多。创建的每个 component 都是一个继承 <code>React.Component</code> 的类。详见 <a href="https://facebook.github.io/react/docs/reusable-components.html" target="_blank" rel="external">react 文档</a></p>
<h3 id="arrow-function"><a href="#arrow-function" class="headerlink" title="arrow function"></a>arrow function</h3><p>这个恐怕是 ES6 最最常用的一个新特性了，用它来写 function 比原来的写法要简洁清晰很多:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function(i)&#123; return i + 1; &#125; //ES5</div><div class="line">(i) =&gt; i + 1 //ES6</div></pre></td></tr></table></figure>
<p>简直是简单的不像话对吧…</p>
<p>如果方程比较复杂，则需要用 <code>{}</code> 把代码包起来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function(x, y) &#123; </div><div class="line">    x++;</div><div class="line">    y--;</div><div class="line">    return x + y;</div><div class="line">&#125;</div><div class="line">(x, y) =&gt; &#123;x++; y--; return x+y&#125;</div></pre></td></tr></table></figure>
<p>除了看上去更简洁以外，arrow function 还有一项超级无敌的功能！</p>
<p>长期以来，JavaScript 语言的 <code>this</code> 对象一直是一个令人头痛的问题，在对象方法中使用 this，必须非常小心。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Animal &#123;</div><div class="line">    constructor()&#123;</div><div class="line">        this.type = &apos;animal&apos;</div><div class="line">    &#125;</div><div class="line">    says(say)&#123;</div><div class="line">        setTimeout(function()&#123;</div><div class="line">            console.log(this.type + &apos; says &apos; + say)</div><div class="line">        &#125;, 1000)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> var animal = new Animal()</div><div class="line"> animal.says(&apos;hi&apos;)  //undefined says hi</div></pre></td></tr></table></figure>
<p>运行上面的代码会报错，这是因为 <code>setTimeout</code> 中的 <code>this</code> 指向的是全局对象。所以为了让它能够正确的运行，传统的解决方法有两种：</p>
<p>1.第一种是将 this 传给 self,再用 self 来指代 this</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">says(say)&#123;</div><div class="line">    var self = this;</div><div class="line">    setTimeout(function()&#123;</div><div class="line">        console.log(self.type + &apos; says &apos; + say)</div><div class="line">    &#125;, 1000)</div></pre></td></tr></table></figure>
<p>2.第二种方法是用 <code>bind(this)</code>,即</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">says(say)&#123;</div><div class="line">    setTimeout(function()&#123;</div><div class="line">        console.log(self.type + &apos; says &apos; + say)</div><div class="line">    &#125;.bind(this), 1000)</div></pre></td></tr></table></figure>
<p>但现在我们有了箭头函数，就不需要这么麻烦了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Animal &#123;</div><div class="line">    constructor()&#123;</div><div class="line">        this.type = &apos;animal&apos;</div><div class="line">    &#125;</div><div class="line">    says(say)&#123;</div><div class="line">        setTimeout( () =&gt; &#123;</div><div class="line">            console.log(this.type + &apos; says &apos; + say)</div><div class="line">        &#125;, 1000)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> var animal = new Animal()</div><div class="line"> animal.says(&apos;hi&apos;)  //animal says hi</div></pre></td></tr></table></figure>
<p>当我们使用箭头函数时，函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>并不是因为箭头函数内部有绑定 this 的机制，实际原因是箭头函数根本没有自己的 this，它的 this 是继承外面的，因此内部的 this 就是外层代码块的 this。</p>
<h3 id="template-string"><a href="#template-string" class="headerlink" title="template string"></a>template string</h3><p>这个东西也是非常有用，当我们要插入大段的 html 内容到文档中时，传统的写法非常麻烦，所以之前我们通常会引用一些模板工具库，比如 mustache 等等。</p>
<p>大家可以先看下面一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$(&quot;#result&quot;).append(</div><div class="line">  &quot;There are &lt;b&gt;&quot; + basket.count + &quot;&lt;/b&gt; &quot; +</div><div class="line">  &quot;items in your basket, &quot; +</div><div class="line">  &quot;&lt;em&gt;&quot; + basket.onSale +</div><div class="line">  &quot;&lt;/em&gt; are on sale!&quot;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>我们要用一堆的 ‘+’ 号来连接文本与变量，而使用 ES6 的新特性模板字符串``后，我们可以直接这么来写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(&quot;#result&quot;).append(`</div><div class="line">  There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items</div><div class="line">   in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt;</div><div class="line">  are on sale!</div><div class="line">`);</div></pre></td></tr></table></figure>
<p>用反引号 （`） 来标识起始，用 ${} 来引用变量，而且所有的空格和缩进都会被保留在输出之中，是不是非常爽？！</p>
<p>React Router 从第1.0.3版开始也使用ES6语法了，比如这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Link to=&#123;`/taco/$&#123;taco.name&#125;`&#125;&gt;&#123;taco.name&#125;&lt;/Link&gt;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/rackt/react-router/blob/latest/examples/passing-props-to-children/app.js" target="_blank" rel="external">React Router</a></p>
<h3 id="destructuring"><a href="#destructuring" class="headerlink" title="destructuring"></a>destructuring</h3><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构 （Destructuring）。</p>
<p>看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let cat = &apos;ken&apos;</div><div class="line">let dog = &apos;lili&apos;</div><div class="line">let zoo = &#123;cat: cat, dog: dog&#125;</div><div class="line">console.log(zoo)  //Object &#123;cat: &quot;ken&quot;, dog: &quot;lili&quot;&#125;</div></pre></td></tr></table></figure>
<p>用ES6完全可以像下面这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let cat = &apos;ken&apos;</div><div class="line">let dog = &apos;lili&apos;</div><div class="line">let zoo = &#123;cat, dog&#125;</div><div class="line">console.log(zoo)  //Object &#123;cat: &quot;ken&quot;, dog: &quot;lili&quot;&#125;</div></pre></td></tr></table></figure>
<p>反过来可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let dog = &#123;type: &apos;animal&apos;, many: 2&#125;</div><div class="line">let &#123; type, many&#125; = dog</div><div class="line">console.log(type, many)   //animal 2</div></pre></td></tr></table></figure>
<h3 id="default-rest"><a href="#default-rest" class="headerlink" title="default, rest"></a>default, rest</h3><p>default 很简单，意思就是默认值。大家可以看下面的例子，调用 <code>animal()</code> 方法时忘了传参数，传统的做法就是加上这一句 <code>type = type || &#39;cat&#39;</code> 来指定默认值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function animal(type)&#123;</div><div class="line">    type = type || &apos;cat&apos;  </div><div class="line">    console.log(type)</div><div class="line">&#125;</div><div class="line">animal()</div></pre></td></tr></table></figure>
<p>如果用 ES6 我们而已直接这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function animal(type = &apos;cat&apos;)&#123;</div><div class="line">    console.log(type)</div><div class="line">&#125;</div><div class="line">animal()</div></pre></td></tr></table></figure>
<p>最后一个 rest 语法也很简单，直接看例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function animals(...types)&#123;</div><div class="line">    console.log(types)</div><div class="line">&#125;</div><div class="line">animals(&apos;cat&apos;, &apos;dog&apos;, &apos;fish&apos;) //[&quot;cat&quot;, &quot;dog&quot;, &quot;fish&quot;]</div></pre></td></tr></table></figure>
<p>而如果不用 ES6 的话，我们则得使用 ES5 的 <code>arguments</code>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是 ES6 最常用的一些语法，可以说这 20% 的语法，在 ES6 的日常使用中占了 80%…</p>
<blockquote>
<p>本文转载自简书，<a href="http://www.jianshu.com/p/ebfeb687eb70" target="_blank">http://www.jianshu.com/p/ebfeb687eb70</a>，作者：Zachary_Wang。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。&lt;/p&gt;
&lt;p&gt;也就是说，ES6就是ES2015。&lt;/p&gt;
&lt;p&gt;虽然目前并不是所有浏览器都能兼容ES6全部特性，但越来越多的程序员在实际项目当中已经开始使用ES6了。所以就算你现在不打算使用ES6，但为了看懂别人的你也该懂点ES6的语法了…&lt;/p&gt;
    
    </summary>
    
      <category term="ES6" scheme="http://songziming.com.cn/categories/ES6/"/>
    
    
      <category term="ES6" scheme="http://songziming.com.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>CSS 中的层叠与特殊性</title>
    <link href="http://songziming.com.cn/2017/01/18/css-cascade/"/>
    <id>http://songziming.com.cn/2017/01/18/css-cascade/</id>
    <published>2017-01-18T02:58:16.000Z</published>
    <updated>2017-06-06T16:10:43.353Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在样式表中，同一个文档元素可能被定义了多条样式规则。碰到这种情况时，CSS 通过一个被称为 <strong>层叠（Cascade）</strong> 的过程来处理冲突。本文介绍了层叠的重要度次序以及样式表规则的特殊性。</p>
<a id="more"></a>
<h2 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h2><p>CSS 层叠是指 CSS 样式在针对同一元素配置同一属性时，依据层叠规则（权重）来处理冲突，它会选择应用权重高的 CSS 选择器所指定的属性。这个过程一般也被描述为权重高的规则覆盖权重低的规则。</p>
<p>层叠给每个规则分配一个重要度，它的重要度次序如下：</p>
<ol>
<li>标有 <code>!important</code> 的用户样式</li>
<li>标有 <code>!important</code> 的作者样式</li>
<li>作者样式</li>
<li>用户样式</li>
<li>浏览器/用户代理应用的默认样式</li>
</ol>
<p>作者的样式表是由站点开发者编写的，被认为是最重要的样式表。用户可以通过浏览器应用自己的样式，这些样式表的重要度低一级。最后是浏览器或用户代理使用的默认样式表，它们的重要度是最低的。但是，如果用户一定要使用自己的样式，可以通过将规则指定为 <code>!important</code> 来提高它的重要度，让它优先于任何规则，甚至优先于作者加上 <code>!important</code> 标志的规则。</p>
<p>在比较了样式规则的重要度之后，CSS 还会根据选择器的 <strong>特殊性</strong> 来决定规则的次序。具有更特殊选择器的规则优先于具有一般选择器的规则。如果两个规则的重要度、来源、特殊性都相同，则后定义的规则优先。</p>
<h2 id="特殊性"><a href="#特殊性" class="headerlink" title="特殊性"></a>特殊性</h2><p>特殊性指的是 CSS 选择器的特殊性。在样式表中，每个 CSS 选择器会被分配一个数字值，将规则的每个选择器的值加在一起，就计算出了规则的特殊性。</p>
<p>选择器的特殊性分为四个等级：a、b、c、d。</p>
<ul>
<li>如果是行内样式，那么a = 1，否则a = 0</li>
<li>b = ID选择器的数量</li>
<li>c = 类、伪类、属性选择器的数量</li>
<li>d = 元素选择器和伪元素选择器的数量</li>
</ul>
<p>使用这些规则可以计算出任何 CSS 选择器的特殊性，abcd四个数字组合的数值最大的特殊性最大，优先级最大。</p>
<blockquote>
<p>注意：通用选择器、子选择器、相邻同胞选择器的特殊性为空。</p>
</blockquote>
<p>下表给出了一系列选择器及其相应的特殊性：</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>特殊性</th>
</tr>
</thead>
<tbody>
<tr>
<td>style = “”</td>
<td>1, 0, 0, 0</td>
</tr>
<tr>
<td>#wrapper #content {}</td>
<td>0, 2, 0, 0</td>
</tr>
<tr>
<td>#content .datePosted {}</td>
<td>0, 1, 1, 0</td>
</tr>
<tr>
<td>div#content {}</td>
<td>0, 1, 0, 1</td>
</tr>
<tr>
<td>#content {}</td>
<td>0, 1, 0, 0</td>
</tr>
<tr>
<td>p.comment .datePosted {}</td>
<td>0, 0, 2, 1</td>
</tr>
<tr>
<td>p.comment {}</td>
<td>0, 0, 1, 1</td>
</tr>
<tr>
<td>div p {}</td>
<td>0, 0, 0, 2</td>
</tr>
<tr>
<td>p {}</td>
<td>0, 0, 0, 1</td>
</tr>
</tbody>
</table>
<p>基本上，行内样式总是比其他任何规则特殊，具有ID选择器的规则比没有ID选择器的规则特殊，具有类选择器的规则比只有元素选择器的规则特殊。</p>
<blockquote>
<p>记住，如果两个规则的特殊性相同，那么后定义的规则胜出。</p>
</blockquote>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承指的是子元素的样式继承父元素的样式。</p>
<blockquote>
<p>很多人将继承和层叠混为一谈，虽然它们初看上去有点相似，但这两个概念实际上是很不一样的。 </p>
</blockquote>
<p>继承不是层叠。层叠是权重高的样式覆盖权重低的样式，而继承是子元素样式继承父元素样式。</p>
<p><strong>继承而来的样式的特殊性为空</strong>（连0特殊性都没有）。如果你在父元素设置了样式，而子元素的样式并没有和父元素样式一样，出现这种情况是因为浏览器带有默认的样式，而继承的样式被浏览器默认的样式覆盖。所以如果不希望使用浏览器的默认样式，需要在样式表开头对样式重置。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在样式表中，同一个文档元素可能被定义了多条样式规则。碰到这种情况时，CSS 通过一个被称为 &lt;strong&gt;层叠（Cascade）&lt;/strong&gt; 的过程来处理冲突。本文介绍了层叠的重要度次序以及样式表规则的特殊性。&lt;/p&gt;
    
    </summary>
    
      <category term="HTML/CSS" scheme="http://songziming.com.cn/categories/HTML-CSS/"/>
    
    
      <category term="层叠" scheme="http://songziming.com.cn/tags/%E5%B1%82%E5%8F%A0/"/>
    
      <category term="特殊性" scheme="http://songziming.com.cn/tags/%E7%89%B9%E6%AE%8A%E6%80%A7/"/>
    
      <category term="继承" scheme="http://songziming.com.cn/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 运算符优先级</title>
    <link href="http://songziming.com.cn/2017/01/03/operator-precedence/"/>
    <id>http://songziming.com.cn/2017/01/03/operator-precedence/</id>
    <published>2017-01-03T14:03:27.000Z</published>
    <updated>2017-04-13T04:48:56.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript 中的 <strong><a href="http://baike.baidu.com/view/262524.htm" title="运算符优先级" target="_blank" rel="external">运算符优先级</a></strong> 是一套规则，它规定了在表达式中运算执行的先后顺序，优先级高的运算符执行总是先于优先级低的运算符。如下例所示，乘法运算符 <code>*</code> 的优先级高于加法运算符 <code>+</code> ，所以在无括号的情况下乘法运算总是先于加法运算进行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(2 + 3 * 5);     //打印的结果为17</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="汇总表"><a href="#汇总表" class="headerlink" title="汇总表"></a>汇总表</h2><p>以下是 JavaScript 中运算符优先级汇总表。供参考：</p>
<table class="table table-bordered table-striped table-condensed"><tr>          <th>优先级</th>          <th>运算类型</th>          <th>关联性</th>          <th>运算符</th>       </tr>       <tr>          <td rowspan="1">19</td>          <td>圆括号</td>          <td>n/a</td>          <td>( … )</td>       </tr>       <tr>          <td rowspan="3">18</td>          <td>成员访问</td>          <td>从左到右</td>          <td>… . …</td>       </tr>       <tr>          <td>需计算的成员访问</td>          <td>从左到右</td>          <td>… [ … ]</td>       </tr>       <tr>          <td>new (带参数列表)</td>          <td>n/a</td>          <td>new … ( … )</td>       </tr>       <tr>          <td rowspan="2">17</td>          <td>函数调用</td>          <td>从左到右</td>          <td>… ( … )</td>       </tr>       <tr>          <td>new (无参数列表)</td>          <td>从右到左</td>          <td>new …</td>       </tr>       <tr>          <td rowspan="2">16</td>          <td>后置递增(运算符在后)</td>          <td>n/a</td>          <td>… ++</td>       </tr>       <tr>          <td>后置递减(运算符在后)</td>          <td>n/a</td>          <td>… –</td>       </tr>       <tr>          <td rowspan="9">15</td>          <td>逻辑非</td>          <td>从右到左</td>          <td>! …</td>       </tr>       <tr>          <td>按位非</td>          <td>从右到左</td>          <td>~ …</td>       </tr>       <tr>          <td>一元加法</td>          <td>从右到左</td>          <td>+ …</td>       </tr>       <tr>          <td>一元减法</td>          <td>从右到左</td>          <td>- …</td>       </tr>       <tr>          <td>前置递增</td>          <td>从右到左</td>          <td>++ …</td>       </tr>       <tr>          <td>前置递减</td>          <td>从右到左</td>          <td>– …</td>       </tr>       <tr>          <td>typeof</td>          <td>从右到左</td>          <td>typeof …</td>       </tr>       <tr>          <td>void</td>          <td>从右到左</td>          <td>void …</td>       </tr>       <tr>          <td>delete</td>          <td>从右到左</td>          <td>delete …</td>       </tr>       <tr>          <td rowspan="3">14</td>          <td>乘法</td>          <td>从左到右</td>          <td>… <em> …</em></td>       </tr>       <tr>          <td>除法</td>          <td>从左到右</td>          <td>… / …</td>       </tr>       <tr>          <td>取模</td>          <td>从左到右</td>          <td>… % …</td>       </tr>       <tr>          <td rowspan="2">13</td>          <td>加法</td>          <td>从左到右</td>          <td>… + …</td>       </tr>       <tr>          <td>减法</td>          <td>从左到右</td>          <td>… - …</td>       </tr>       <tr>          <td rowspan="3">12</td>          <td>按位左移</td>          <td>从左到右</td>          <td>… &lt;&lt; …</td>       </tr>       <tr>          <td>按位右移</td>          <td>从左到右</td>          <td>… &gt;&gt; …</td>       </tr>       <tr>          <td>无符号右移</td>          <td>从左到右</td>          <td>… &gt;&gt;&gt; …</td>       </tr>       <tr>          <td rowspan="6">11</td>          <td>小于</td>          <td>从左到右</td>          <td>… &lt; …</td>       </tr>       <tr>          <td>小于等于</td>          <td>从左到右</td>          <td>… &lt;= …</td>       </tr>       <tr>          <td>大于</td>          <td>从左到右</td>          <td>… &gt; …</td>       </tr>       <tr>          <td>大于等于</td>          <td>从左到右</td>          <td>… &gt;= …</td>       </tr>       <tr>          <td>in</td>          <td>从左到右</td>          <td>… in …</td>       </tr>       <tr>          <td>instanceof</td>          <td>从左到右</td>          <td>… instanceof …</td>       </tr>       <tr>          <td rowspan="4">10</td>          <td>等号</td>          <td>从左到右</td>          <td>… == …</td>       </tr>       <tr>          <td>非等号</td>          <td>从左到右</td>          <td>… != …</td>       </tr>       <tr>          <td>全等号</td>          <td>从左到右</td>          <td>… === …</td>       </tr>       <tr>          <td>非全等号</td>          <td>从左到右</td>          <td>… !== …</td>       </tr>       <tr>          <td>9</td>          <td>按位与</td>          <td>从左到右</td>          <td>… &amp; …</td>       </tr>       <tr>          <td>8</td>          <td>按位异或</td>          <td>从左到右</td>          <td>… ^ …</td>       </tr>       <tr>          <td>7</td>          <td>按位或</td>          <td>从左到右</td>          <td>… | …</td>       </tr>       <tr>          <td>6</td>          <td>逻辑与</td>          <td>从左到右</td>          <td>… &amp;&amp; …</td>       </tr>       <tr>          <td>5</td>          <td>逻辑或</td>          <td>从左到右</td>          <td>… || …</td>       </tr>       <tr>          <td>4</td>          <td>条件运算符</td>          <td>从右到左</td>          <td>… ? … : …</td>       </tr>       <tr>          <td rowspan="12">3</td>          <td rowspan="12">赋值</td>          <td rowspan="12">从右到左</td>          <td>… = …</td>       </tr>       <tr>          <td>… += …</td>       </tr>       <tr>          <td>… -= …</td>       </tr>       <tr>          <td>… = …</td>       </tr>       <tr>          <td>… /= …</td>       </tr>       <tr>          <td>… %= …</td>       </tr>       <tr>          <td>… &lt;&lt;= …</td>       </tr>       <tr>          <td>… &gt;&gt;= …</td>       </tr>       <tr>          <td>… &gt;&gt;&gt;= …</td>   </tr>       <tr>          <td>… &amp;= …</td>       </tr>       <tr>          <td>… ^= …</td>       </tr>       <tr>          <td>… |= …</td>       </tr>       <tr>          <td rowspan="2">2</td>          <td>yield</td>          <td>从右到左</td>          <td>yield …</td>       </tr>       <tr>          <td>yield<em></em></td>          <td>从右到左</td>          <td>yield …</td>       </tr>       <tr>          <td>1</td>          <td>展开运算符</td>          <td>n/a</td>          <td>… …</td>       </tr>       <tr>          <td>0</td>          <td>逗号</td>          <td>从左到右</td>          <td>… , …</td>       </tr>    </table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;JavaScript 中的 &lt;strong&gt;&lt;a href=&quot;http://baike.baidu.com/view/262524.htm&quot; title=&quot;运算符优先级&quot;&gt;运算符优先级&lt;/a&gt;&lt;/strong&gt; 是一套规则，它规定了在表达式中运算执行的先后顺序，优先级高的运算符执行总是先于优先级低的运算符。如下例所示，乘法运算符 &lt;code&gt;*&lt;/code&gt; 的优先级高于加法运算符 &lt;code&gt;+&lt;/code&gt; ，所以在无括号的情况下乘法运算总是先于加法运算进行的。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;console.log(2 + 3 * 5);     //打印的结果为17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://songziming.com.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://songziming.com.cn/tags/JavaScript/"/>
    
      <category term="运算符" scheme="http://songziming.com.cn/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
      <category term="优先级" scheme="http://songziming.com.cn/tags/%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>CSS 盒模型</title>
    <link href="http://songziming.com.cn/2016/12/16/CSS-box-model/"/>
    <id>http://songziming.com.cn/2016/12/16/CSS-box-model/</id>
    <published>2016-12-16T10:31:53.000Z</published>
    <updated>2017-06-06T16:10:53.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>HTML 文档中的每个元素被描绘为矩形盒子，在 CSS 中这些矩形盒子用 <strong>标准盒模型（Box Model）</strong> 来描述。这个模型描述了一个元素所占用的空间，规定了元素框处理元素 <em>内容</em> 、 <em>内边距</em> 、 <em>边框</em> 和 <em>外边距</em> 的方式。标准盒模型如下图所示：</p>
<a id="more"></a>
<img src="/2016/12/16/CSS-box-model/1.png" alt="标准盒模型" title="标准盒模型">
<p>盒模型的最内部分是实际的元素 <em>内容（content）</em> ，它用来显示文本或图像等。</p>
<p>包围在内容外面的是分别是 <em>内边距（padding）</em> 、 <em>边框（border）</em> 和 <em>外边距（margin）</em> 。</p>
<blockquote>
<p>内边距、边框和外边距都是可选的，默认值是零。但是，许多元素将由用户代理样式表（浏览器内置样式表）设置外边距和内边距。你可以自己定义元素的 <code>margin</code> 和 <code>padding</code> 来覆盖这些浏览器样式。</p>
<p>元素定义的背景应用于由内容、内边距和边框组成的区域，元素的外边距是透明的。</p>
</blockquote>
<p>在 CSS 标准盒模型中，<code>width</code> 和 <code>height</code> 指的是内容区域的宽度和高度，它不包含元素的内边距、边框、外边距所需的任何额外空间。所以一个元素框的实际尺寸计算方式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">boxWidth = margin(left+right) + border(left+right) + padding(left+right) + width(content)</div><div class="line"></div><div class="line">boxHeight = margin(top+bottom) + border(top+bottom) + padding(top+bottom) + height(content)</div></pre></td></tr></table></figure>
<h3 id="边框盒模型与-box-sizing-属性"><a href="#边框盒模型与-box-sizing-属性" class="headerlink" title="边框盒模型与 box-sizing 属性"></a>边框盒模型与 box-sizing 属性</h3><p>标准 CSS 盒模型规定 <code>width</code> 和 <code>height</code> 样式属性给定元素内容区域的尺寸，并且不包含内边距和边框，这种标准的盒模型可以被称作 “内容盒模型” 。</p>
<p>但在 IE 6之前的 IE 浏览器和当 IE 6~8在 “怪异模式” 下显示一个页面时（页面缺少 <code>&lt;!DOCTYPE&gt;</code> 或有一个不够严格的 doctype 时），<code>width</code> 和 <code>height</code> 属性是包含内边距和边框宽度的。IE 的这种行为是一个 bug ，但是这种非标准盒模型有时候也很有用。</p>
<p>因此 CSS3 引进了一个 <code>box-sizing</code> 属性，它的默认值是 <code>content-box</code> ，也就是标准的盒模型。如果将它设置为 <code>box-sizing: border-box</code> ，浏览器就会为那个元素应用边框盒模型，即 <code>width</code> 和 <code>height</code> 属性将包含边框和内边距。</p>
<h3 id="定位元素的应用细节"><a href="#定位元素的应用细节" class="headerlink" title="定位元素的应用细节"></a>定位元素的应用细节</h3><p>下图显示了一个绝对定位的元素嵌套在一个定位的容器元素中。容器和包含的子元素都有边框和内边距，图中说明了指定容器元素每条边的内边距和边框宽度的 CSS 属性。</p>
<img src="/2016/12/16/CSS-box-model/2.png" alt="盒模型中的定位元素" title="盒模型中的定位元素">
<blockquote>
<p>注意，图中并没有标注外边距属性，因为外边距与绝对定位的元素无关。</p>
</blockquote>
<p>如图所示，<code>left</code> 和 <code>top</code> 属性指定了从容器边框内侧到定位元素边框外侧的距离。这些属性不是从容器内容区域的左上角开始度量的，而是从容器内边距的左上角开始的。同样，<code>right</code> 和 <code>bottom</code> 属性是从容器内边距的右下角开始度量的。</p>
<h2 id="垂直外边距合并"><a href="#垂直外边距合并" class="headerlink" title="垂直外边距合并"></a>垂直外边距合并</h2><p>CSS 盒模型有一个非常重要的特性就是 <strong>垂直外边距合并</strong> ，它指的是在文档正常流中，当两个元素框的垂直外边距相遇时，它们将形成一个外边距。</p>
<p>合并后的外边距的高度等于两个发生合并的外边距高度中的较大者。</p>
<p>当一个元素出现在另一个元素上面时，第一个元素的下外边距与第二个元素的上外边距会发生合并。如下图所示：</p>
<img src="/2016/12/16/CSS-box-model/3.png" alt="垂直外边距合并" title="垂直外边距合并">
<p>当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和下外边距也会发生合并。如下图所示：</p>
<img src="/2016/12/16/CSS-box-model/4.png" alt="垂直外边距合并" title="垂直外边距合并">
<p>外边距甚至可以与自身发生合并，假设有一个空元素，它有外边距，但是没有边框或内边距。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并：</p>
<img src="/2016/12/16/CSS-box-model/5.png" alt="垂直外边距合并" title="垂直外边距合并">
<p>如果这个外边距遇到另一个元素的外边距，它还会发生合并：</p>
<img src="/2016/12/16/CSS-box-model/6.png" alt="垂直外边距合并" title="垂直外边距合并">
<p>外边距合并既能够节省页面空间又能使页面更加美观。</p>
<img src="/2016/12/16/CSS-box-model/7.png" alt="垂直外边距合并" title="垂直外边距合并">
<blockquote>
<p><em>注意</em> ：只有 <strong>普通文档流</strong> 中 <strong>块框</strong> 的 <strong>垂直外边距</strong> 才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。所有元素的内边距、边框以及水平外边距也都不会合并。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;HTML 文档中的每个元素被描绘为矩形盒子，在 CSS 中这些矩形盒子用 &lt;strong&gt;标准盒模型（Box Model）&lt;/strong&gt; 来描述。这个模型描述了一个元素所占用的空间，规定了元素框处理元素 &lt;em&gt;内容&lt;/em&gt; 、 &lt;em&gt;内边距&lt;/em&gt; 、 &lt;em&gt;边框&lt;/em&gt; 和 &lt;em&gt;外边距&lt;/em&gt; 的方式。标准盒模型如下图所示：&lt;/p&gt;
    
    </summary>
    
      <category term="HTML/CSS" scheme="http://songziming.com.cn/categories/HTML-CSS/"/>
    
    
      <category term="盒模型" scheme="http://songziming.com.cn/tags/%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="内容盒模型" scheme="http://songziming.com.cn/tags/%E5%86%85%E5%AE%B9%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="边框盒模型" scheme="http://songziming.com.cn/tags/%E8%BE%B9%E6%A1%86%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="垂直外边距" scheme="http://songziming.com.cn/tags/%E5%9E%82%E7%9B%B4%E5%A4%96%E8%BE%B9%E8%B7%9D/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中的正则表达式</title>
    <link href="http://songziming.com.cn/2016/12/02/RegExp-in-JavaScript/"/>
    <id>http://songziming.com.cn/2016/12/02/RegExp-in-JavaScript/</id>
    <published>2016-12-02T13:59:44.000Z</published>
    <updated>2017-04-13T04:51:45.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="external">正则表达式（Regular Expression）</a> 是一个描述字符模式的对象，它被用来匹配字符串中的字符组合。 JavaScript 中的 String 类和 RegExp 类都定义了使用正则表达式的方法。</p>
<a id="more"></a>
<h2 id="正则表达式的定义"><a href="#正则表达式的定义" class="headerlink" title="正则表达式的定义"></a>正则表达式的定义</h2><p>JavaScript 中的正则表达式用 RegExp 对象表示，所以我们可以使用 RegExp() 构造函数来创建 RegExp 对象，不过在实际 使用中 RegExp 对象更多的是通过直接量语法来创建的。正则表达式直接量定义为包含在一对斜杠 <code>&quot;/&quot;</code> 之间的字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var expression1 = /pattern/flags;           //RegExp直接量</div><div class="line">var expression2 = new RegExp(&quot;pattern&quot;, &quot;flags&quot;);    //RegExp构造函数</div></pre></td></tr></table></figure>
<blockquote>
<p>flags 代表修饰符，本文稍后有详细介绍。</p>
</blockquote>
<h3 id="直接量字符"><a href="#直接量字符" class="headerlink" title="直接量字符"></a>直接量字符</h3><p>正则表达式中的所有字母和数字都是按照字面含义进行匹配的，但它也支持通过反斜线 <code>&quot;\&quot;</code> 转义的非字母的字符匹配，这些转义字符如下表所示：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>匹配</th>
</tr>
</thead>
<tbody>
<tr>
<td>字母和数字字符</td>
<td>自身</td>
</tr>
<tr>
<td>\o</td>
<td>NUL字符（\u0000）</td>
</tr>
<tr>
<td>\t</td>
<td>制表符（\u0009）</td>
</tr>
<tr>
<td>\n</td>
<td>换行符（\u000A）</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表符（\u000B）</td>
</tr>
<tr>
<td>\f</td>
<td>换页符（\u000C）</td>
</tr>
<tr>
<td>\r</td>
<td>回车符（\u000D）</td>
</tr>
<tr>
<td>\xnn</td>
<td>由十六进制数 nn 指定的拉丁字符，例如 \x0A 等价于 \n</td>
</tr>
<tr>
<td>\uxxxx</td>
<td>由十六进制数 xxxx 指定的 Unicode 字符，例如 \u0009 等价于 \t</td>
</tr>
<tr>
<td>\cX</td>
<td>控制字符 ^X，例如 \cJ 等价于换行符 \n</td>
</tr>
</tbody>
</table>
<h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><p>将直接量字符单独放进方括号内就组成了字符类，一个字符类可以匹配它所包含的任意字符。例如，正则表达式 <code>/[abc]/</code> 就和字母 <code>&quot;a&quot;, &quot;b&quot;, &quot;c&quot;</code> 中的任意一个都匹配。正则表达式的字符类也支持转义字符定义的特殊字符，如下表所示：</p>
<img src="/2016/12/02/RegExp-in-JavaScript/1.png" alt="字符类" title="字符类">
<h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><p>正则表达式中还有一些重复字符语法，如下表所示：</p>
<img src="/2016/12/02/RegExp-in-JavaScript/2.png" alt="重复" title="重复">
<p>举一些栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/\d&#123;2,4&#125;/     //匹配2~4个数字</div><div class="line">/\w&#123;3&#125;\d?/    //精确匹配三个单词字符和一个可选的数字</div><div class="line">/\s+java\s+/  //匹配前后带有一个或多个空格的字符串&quot;java&quot;</div><div class="line">/[^(]*/       //匹配一个或多个非左括号的字符</div></pre></td></tr></table></figure>
<h3 id="选择与分组"><a href="#选择与分组" class="headerlink" title="选择与分组"></a>选择与分组</h3><p>字符 <code>&quot;|&quot;</code> 用于分隔供选择的字符。例如， <code>/ab|cd|ef/</code> 可以匹配字符串 <code>&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;</code> ； <code>/\d{3}|[a-z]{4}/</code> 匹配三位数字或四个小写字母。</p>
<blockquote>
<p>注意，选择项的尝试匹配次序是从左到右，直到发现匹配项。如果左边的选择项匹配，就忽略右边的匹配项，即使它产生更好的匹配。例如，当 <code>/a|ab/</code> 匹配字符串 <code>&quot;ab&quot;</code> 时，它只能匹配第一个字符。</p>
</blockquote>
<p>正则表达式的圆括号作用是把单独的项组合成子表达式，还可以在完整的模式中定义子模式。例如，<code>/java(script)?/</code> 可以匹配字符串 <code>&quot;java&quot;</code> ，其后可以有 <code>&quot;script&quot;</code> 也可以没有。</p>
<h3 id="指定匹配位置"><a href="#指定匹配位置" class="headerlink" title="指定匹配位置"></a>指定匹配位置</h3><p>在正则表达式中，有一些锚字符，用来指定字符串中的特殊位置，如下表所示：</p>
<img src="/2016/12/02/RegExp-in-JavaScript/3.png" alt="特殊位置" title="特殊位置">
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>正则表达式还有3个修饰符，分别是 <code>&quot;i&quot;, &quot;g&quot;, &quot;m&quot;</code> 。它们放在字面量的 <code>&quot;/&quot;</code> 符号之外，是 RegExp() 构造函数的第二个参数。它们的含义如下表所示：</p>
<img src="/2016/12/02/RegExp-in-JavaScript/4.png" alt="修饰符" title="修饰符">
<h2 id="用于模式匹配的-String-方法"><a href="#用于模式匹配的-String-方法" class="headerlink" title="用于模式匹配的 String 方法"></a>用于模式匹配的 String 方法</h2><h3 id="search-方法"><a href="#search-方法" class="headerlink" title="search() 方法"></a>search() 方法</h3><p>search() 方法的参数是一个正则表达式，返回第一个与之匹配的子串的起始位置，若无匹配的子串，则返回 -1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;JavaScript&quot;.search(/script/i);          //将返回4</div></pre></td></tr></table></figure>
<p>若 search() 方法的参数不是正则表达式，则首先会通过 RegExp() 构造函数将它转换为正则表达式。</p>
<p>search() 方法不支持全局搜索，因为它会忽略正则表达式参数中的修饰符 <code>g</code> 。</p>
<h3 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace() 方法"></a>replace() 方法</h3><p>replace() 方法用以执行检索与替换操作，它的第一个参数是正则表达式，第二个参数是要替换的字符串。它支持全局替换，不会忽略 <code>g</code> 修饰符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">text.replace(/javascript/gi, &quot;JavaScript&quot;);      //将text中所有不区分大小写的javascript都替换为JavaScript</div></pre></td></tr></table></figure>
<p>若 replace() 方法第一个参数是字符串而不是正则表达式，则它会直接搜索这个字符串，不会像 search() 方法那样通过 RegExp() 构造函数转换为正则表达式。</p>
<h3 id="match-方法"><a href="#match-方法" class="headerlink" title="match() 方法"></a>match() 方法</h3><p>match() 方法是最常用的 String 正则表达式方法，它的参数是一个正则表达式（若不是正则表达式会通过 RegExp() 构造函数转换），返回的是一个由匹配结果组成的数组。</p>
<p>若参数的正则表达式设置了 <code>g</code> 修饰符，则该方法返回的是一个包含所有匹配结果的数组。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;1 plus 2 equals 3&quot;.match(/\d+/g);   //返回[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</div></pre></td></tr></table></figure>
<p>若参数的正则表达式没有设置 <code>g</code> 修饰符，它不会进行全局搜索，但也返回一个数组，数组第一个元素是匹配的字符串，余下的元素是正则表达式中用圆括号括起来的子表达式匹配的字符串。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var url = /(\w+):\/\/([\w.]+)/;</div><div class="line">var text = &quot;Visit my blog at http://songziming.com.cn&quot;;</div><div class="line">var result = text.match(url);</div><div class="line">/*  [&quot;http://songziming.com.cn&quot;,</div><div class="line">     &quot;http&quot;,</div><div class="line">     &quot;songziming.com.cn&quot;,</div><div class="line">     &quot;~szm&quot;</div><div class="line">    ]</div><div class="line">*/</div></pre></td></tr></table></figure>
<h3 id="split-方法"><a href="#split-方法" class="headerlink" title="split() 方法"></a>split() 方法</h3><p>split() 用来分隔字符串为数组，它的参数既能是一个字符串也能是一个正则表达式（字符串不会通过 RegExp() 构造函数转换为正则表达式）。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;123,456,789&quot;.split(&quot;,&quot;);   //返回[&quot;123&quot;, &quot;456&quot;, &quot;789&quot;]</div><div class="line">&quot;1, 2, 3, 4&quot;.split(/\s*,\s*/);  //返回[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;]</div></pre></td></tr></table></figure>
<h2 id="RegExp-对象"><a href="#RegExp-对象" class="headerlink" title="RegExp 对象"></a>RegExp 对象</h2><p>文章开头讲到过，正则表达式还能通过 RegExp() 构造函数创建，它带有两个参数，第一个参数是正则表达式的主体部分，第二个参数可选，是修饰符。不过需要注意的是，在主体部分，不论是字符串直接量还是正则表达式，都需要使用 “\” 字符作为转义字符的前缀，因此当给 RegExp() 传入一个字符串表述的正则表达式时，必须将 “\” 替换为 “\“ 。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var zipcode = new RegExp(&quot;\\d&#123;5&#125;&quot;, &quot;g&quot;);   //全局匹配字符串中的5个数字</div></pre></td></tr></table></figure>
<h3 id="RegExp-对象的属性"><a href="#RegExp-对象的属性" class="headerlink" title="RegExp 对象的属性"></a>RegExp 对象的属性</h3><p>每个 RegExp 对象都具有5个属性，如下图所示：</p>
<img src="/2016/12/02/RegExp-in-JavaScript/5.png" alt="RegExp对象属性" title="RegExp对象属性">
<p>其中，global, ignoreCase, multiline 都是只读的布尔值，source 是一个只读的字符串，lastIndex 是一个可读可写的整数。</p>
<h3 id="RegExp-对象的方法"><a href="#RegExp-对象的方法" class="headerlink" title="RegExp 对象的方法"></a>RegExp 对象的方法</h3><h4 id="exec-方法"><a href="#exec-方法" class="headerlink" title="exec() 方法"></a>exec() 方法</h4><p>exec() 是 RegExp 对象最主要的模式匹配方法，它与 String 的 match() 方法非常相似。</p>
<p>exec() 方法的参数是一个字符串，它执行对这个字符串的匹配搜索。如果没有找到任何匹配，就返回 null；如果找到了一个匹配，它将返回一个数组，就像 match() 方法为非全局检索返回的数组一样。数组第一个元素与正则表达式匹配的字符串，余下的元素是与圆括号内的子表达式匹配的子串。返回的数组还包括了 index 与 input 两个属性，index 属性包含了发生匹配的字符位置，input 属性引用的是正在检索的字符串。</p>
<p>不管正则表达式是否具有g修饰符，exec() 方法都返回一样的数组。当同一个正则表达式第二次调用 exec() 方法时，将从 lastIndex 的位置开始检索。若 exec() 没有发现任何匹配结果，则将 lastIndex 重置为0。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var pattern = /Java/g;</div><div class="line">var text = &quot;JavaScript is more fun than Java!&quot;;</div><div class="line">var result;</div><div class="line">while((result = pattern.exec(text)) !== null) &#123;</div><div class="line">     alert(&quot;Matched &apos;&quot; + result[0] + &quot;&apos;&quot; +</div><div class="line">          &quot; at position &quot; + result.index +</div><div class="line">          &quot;; next search begins at &quot; + pattern.lastIndex);</div></pre></td></tr></table></figure>
<h4 id="test-方法"><a href="#test-方法" class="headerlink" title="test() 方法"></a>test() 方法</h4><p>test() 方法的参数是一个字符串，返回一个指示是否匹配的布尔值。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var pattern = /java/i;</div><div class="line">pattern.test(&quot;JavaScript&quot;);    //返回true</div></pre></td></tr></table></figure>
<p>调用 test() 与 exec() 等价。当一个全局正则表达式调用 test() 时，它会从 lastIndex 的位置开始检索，若找到了匹配结果，那么它就会设置 lastIndex 为当前匹配子串的结束位置。</p>
<blockquote>
<p>由于这个特性的存在，如果让一个带有 <code>g</code> 修饰符的正则表达式对多个字符串执行 exec() 或 test() 时，要么在每个字符串中找出所有的匹配以便将 lastIndex 自动重置为 0，要么需要手动重置 lastIndex 为 0。否则，下一次对新字符串进行检索时，起始位置可能就不是字符串的开始位置了。</p>
<p>在 ECMAScript 5 中，正则表达式直接量每次计算都会创建一个新的 RegExp 对象，因此每次对新字符串检索时 lastIndex 都是0。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F&quot;&gt;正则表达式（Regular Expression）&lt;/a&gt; 是一个描述字符模式的对象，它被用来匹配字符串中的字符组合。 JavaScript 中的 String 类和 RegExp 类都定义了使用正则表达式的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://songziming.com.cn/categories/JavaScript/"/>
    
    
      <category term="正则表达式" scheme="http://songziming.com.cn/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="RegExp" scheme="http://songziming.com.cn/tags/RegExp/"/>
    
      <category term="字符串" scheme="http://songziming.com.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="模式匹配" scheme="http://songziming.com.cn/tags/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>PHP 中单引号与双引号的区别</title>
    <link href="http://songziming.com.cn/2016/11/06/php-quote-md/"/>
    <id>http://songziming.com.cn/2016/11/06/php-quote-md/</id>
    <published>2016-11-06T12:37:16.000Z</published>
    <updated>2017-04-13T04:52:12.638Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>应该大部分人都知道，在 C、 C++、 Java 等语言中，单引号引用的是单个字符，双引号引用的是一个字符串。笔者之前接触 JavaScript 比较多，在 JavaScript 中单双引号是没有区别的，都可用于引用 string 类型的变量（ <em>在 JSON 中，字符串必须加双引号，单引号会导致语法错误</em> ）。但笔者最近才发现，在 PHP 中单双引号的区别与这些语言都不一样，以下谨作为记录。</p>
<a id="more"></a>
<h2 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h2><p>在 PHP 中，用单引号（’）把一个字符串包围起来，代表引用的仅仅是这个字符串本身。也就是说变量 <code>$test</code> 以及转义序列 <code>\n</code> 或者 <code>\r</code> 等并不代表任何含义，就单纯是这几个字符串本身。举几个简单栗子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$test = &apos;data&apos;;</div><div class="line">echo &apos;$test is a variable.&apos;;        //输出 $test is a variable.</div><div class="line">echo &apos;$test is a variable.\n&apos;;      //输出 $test is a variable.\n</div></pre></td></tr></table></figure>
<h2 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h2><p>与上述所说的单引号不同，PHP中的双引号（”）则会对变量、转义字符等特殊字符进行解析。举几个栗子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$test = &apos;data&apos;;</div><div class="line">echo &quot;$test is a variable.&quot;;        //输出 data is a variable.</div><div class="line">echo &quot;$test is a variable.\n&quot;;      //输出 data is a variable.（同时换行）</div></pre></td></tr></table></figure>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>总结成一句话就是，<strong> PHP 里的单引号把内容当成纯文本，不经过服务器翻译，而双引号里面的内容则会经过服务器处理</strong>。由于存在这个区别，在PHP中使用引号时结合点操作符（.）操作字符串就可以非常灵活了。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$name = &apos;szm&apos;;</div><div class="line">echo &apos;My name is &apos;.$name.&apos;.&apos;;</div><div class="line">echo &quot;My name is $name.&quot;;</div><div class="line"></div><div class="line">//两个输出都是 My name is szm.</div></pre></td></tr></table></figure>
<p>怎么样，是不是觉得PHP的这个特性很神奇？</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;应该大部分人都知道，在 C、 C++、 Java 等语言中，单引号引用的是单个字符，双引号引用的是一个字符串。笔者之前接触 JavaScript 比较多，在 JavaScript 中单双引号是没有区别的，都可用于引用 string 类型的变量（ &lt;em&gt;在 JSON 中，字符串必须加双引号，单引号会导致语法错误&lt;/em&gt; ）。但笔者最近才发现，在 PHP 中单双引号的区别与这些语言都不一样，以下谨作为记录。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://songziming.com.cn/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://songziming.com.cn/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的回调函数</title>
    <link href="http://songziming.com.cn/2016/10/30/callback/"/>
    <id>http://songziming.com.cn/2016/10/30/callback/</id>
    <published>2016-10-30T14:48:39.000Z</published>
    <updated>2017-04-13T04:52:43.463Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是回调函数"><a href="#什么是回调函数" class="headerlink" title="什么是回调函数"></a>什么是回调函数</h2><p><a href="http://https://zh.wikipedia.org/wiki/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0" target="_blank" rel="external">回调函数（Callback）</a> 是一段可执行的代码段（通常包装成一个函数），它会作为一个参数传递给其他的代码（通常也是一个函数）。回调函数会等待父函数执行完毕后立即执行，而与此同时，其他函数的调用不会受到阻塞。</p>
<a id="more"></a>
<blockquote>
<p>A callback is a function that is passed as an argument to another function and is executed after its parent function has completed. Callbacks are special because they patiently wait to execute until their parent finishes. Meanwhile, the browser can be executing other functions or doing all sorts of other work.</p>
<p>— <a href="http://learn.jquery.com/" target="_blank" rel="external">jQuery</a> 官网</p>
</blockquote>
<p>打个比方，你到一个商店买东西，不巧你要的东西没货了，你会怎么办呢？</p>
<ol>
<li>每天去一趟商店，看东西到货了没</li>
<li>你给店员留了个电话，让他等东西到货后马上给你打电话</li>
</ol>
<p>前者是轮询，后者就是回调。</p>
<p>在这个回调机制里，你的电话号码就是回调函数，你把电话留给店员叫传递回调函数，东西到货叫做触发回调关联的事件，店员给你打电话就是调用回调函数。</p>
<h2 id="回调函数怎么用"><a href="#回调函数怎么用" class="headerlink" title="回调函数怎么用"></a>回调函数怎么用</h2><p>上面已经提到，JavaScript 中的回调函数一般都是作为参数传递给另外一个函数。下面分回调函数有没有参数两种情况分别说明如何传递它给父函数。</p>
<h3 id="没有参数的回调函数"><a href="#没有参数的回调函数" class="headerlink" title="没有参数的回调函数"></a>没有参数的回调函数</h3><p>如果回调函数没有参数，那么你可以这么传递给父函数：</p>
<pre><code>$.get( &quot;mypage.html&quot;, myCallBack );
</code></pre><p>当 <code>$.get()</code> 函数请求 <code>mypage.html</code> 完毕后，浏览器就会执行 <code>myCallBack()</code> 函数。</p>
<blockquote>
<p>注意，第二个参数就是函数名形式传递给父函数，不要把它写成了字符串形式，即不能加引号。</p>
</blockquote>
<h3 id="带有参数的回调函数"><a href="#带有参数的回调函数" class="headerlink" title="带有参数的回调函数"></a>带有参数的回调函数</h3><p>如果回调函数带有参数，很多人第一反应会这么使用：</p>
<pre><code>$.get( &quot;mypage.html&quot;, myCallBack( param1, param2 ) );   //Wrong!!!
</code></pre><p>这就大错特错啦！</p>
<p>因为这行代码会先执行 <code>myCallBack( param1, param2 )</code> 函数，然后把这个 <strong>函数的返回值</strong> 作为参数传递给 <code>$.get()</code> 。如果你确实想这么做，那当然是可以的。</p>
<p>但如果你是想把带有参数的 <code>myCallBack()</code> 作为回调函数使用，你就必须使用 <em>匿名函数</em> 把它包装起来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$.get( &quot;mypage.html&quot;, function() &#123;</div><div class="line"> </div><div class="line">    myCallBack( param1, param2 );</div><div class="line"> </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>这个匿名函数只做一件事，就是调用带有参数 <code>param1</code> 与 <code>param2</code> 的函数 <code>myCallBack()</code> 。</p>
</blockquote>
<p>当 <code>$.get()</code> 函数请求 <code>mypage.html</code> 完毕后，浏览器就会执行这个匿名函数，也就相当于执行 <code>myCallBack( param1, param2 )</code> 。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在 JavaScript 中回调函数几乎无处不在。回调本质上是一种设计模式，这种机制为编程提供了非常大的灵活性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是回调函数&quot;&gt;&lt;a href=&quot;#什么是回调函数&quot; class=&quot;headerlink&quot; title=&quot;什么是回调函数&quot;&gt;&lt;/a&gt;什么是回调函数&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://https://zh.wikipedia.org/wiki/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0&quot;&gt;回调函数（Callback）&lt;/a&gt; 是一段可执行的代码段（通常包装成一个函数），它会作为一个参数传递给其他的代码（通常也是一个函数）。回调函数会等待父函数执行完毕后立即执行，而与此同时，其他函数的调用不会受到阻塞。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://songziming.com.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://songziming.com.cn/tags/JavaScript/"/>
    
      <category term="回调函数" scheme="http://songziming.com.cn/tags/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    
      <category term="Callback" scheme="http://songziming.com.cn/tags/Callback/"/>
    
  </entry>
  
  <entry>
    <title>简单谈谈 GET 与 POST 的区别</title>
    <link href="http://songziming.com.cn/2016/10/19/get-vs-post/"/>
    <id>http://songziming.com.cn/2016/10/19/get-vs-post/</id>
    <published>2016-10-19T15:29:42.000Z</published>
    <updated>2016-11-05T10:19:20.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" title="HyperText Transfer Protocol" target="_blank" rel="external">HTTP（超文本传输协议)</a> 是目前互联网上应用最为广泛的一种 <a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="external">网络协议</a> ，Web 网络中 <a href="https://zh.wikipedia.org/wiki/%E5%AE%A2%E6%88%B7%E7%AB%AF" target="_blank" rel="external">客户端(Client)</a> 到 <a href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="external">服务器端(Server)</a> 的通信就是建立在 HTTP 协议上。</p>
<img src="/2016/10/19/get-vs-post/request.png" alt="Communication between Client and Server." title="Communication between Client and Server.">
<p>HTTP 定义了几种客户端向服务器端发出请求的方法，如 GET、POST、HEAD、DELETE、OPTIONS、TRACE、CONNECT 等。但最常用的还是 GET 与 POST 方法，这两个方法之间的区别也是很多互联网公司面试官喜欢问的问题，下面笔者就来简单谈谈。</p>
<a id="more"></a>
<h2 id="GET-方法"><a href="#GET-方法" class="headerlink" title="GET 方法"></a>GET 方法</h2><p>1.<strong>GET 方法主要用于对服务器资源的获取。</strong>根据<a href="https://www.w3.org/Protocols/rfc2616/rfc2616.txt" target="_blank" rel="external"> HTTP 规范</a> ，它应该是 <strong>安全</strong> 的和 <a href="https://zh.wikipedia.org/wiki/%E5%86%AA%E7%AD%89" target="_blank" rel="external"><strong>幂等</strong></a> 的。</p>
<blockquote>
<p><em>安全</em> 指的是它的操作应该是无损害(non-destructive)的。通过 GET 方法，你（客户端）仅仅是从服务器端<code>获取</code>信息，而不会增加、修改数据，不会更改服务器上的资源。</p>
<p><em>幂等</em> 指的是客户端对同一 <a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6" target="_blank" rel="external">URL</a> 的多次请求应该返回同样的结果。</p>
</blockquote>
<p>2.<strong>GET 请求的查询字符串（键值对）是随 URL 一起发送的。</strong>URL 和传输数据以 <code>?</code> 分割，参数之间以 <code>&amp;</code> 相连，如 <code>/test/demo_form.asp?name1=value1&amp;name2=value2</code> 。</p>
<blockquote>
<p>正因如此，处理敏感数据（如密码）时，不应使用 GET 方法。</p>
</blockquote>
<p>3.<strong>GET 方法传输数据的长度是有限制的。</strong></p>
<blockquote>
<p>虽然在 HTTP 规范中，GET 请求数据的长度和 URL 长度都是无限制的，但实际上，大多数浏览器会限制 URL 长度(如 IE 浏览器限制在2083 bit）。因此 GET 请求传输数据的长度会有所限制。</p>
</blockquote>
<p>4.<strong>GET 请求可以被浏览器缓存。</strong></p>
<blockquote>
<p>因此，通过 GET 方法返回的数据可能是浏览器缓存的数据。</p>
</blockquote>
<p>5.<strong>GET 请求保留在浏览器历史记录中且可被收藏为书签。</strong></p>
<blockquote>
<p>笔者认为这一点也是 <em>查询字符串会随 URL 一起发送</em> 的缘故。</p>
</blockquote>
<p>6.<strong>GET 方法传输的数据只能是 ASCII 码格式，否则需要 URL 编码才能进行传输。</strong></p>
<blockquote>
<p>这也是由于 URL 的编码格式采用的是 ASCII 码。</p>
</blockquote>
<h2 id="POST-方法"><a href="#POST-方法" class="headerlink" title="POST 方法"></a>POST 方法</h2><p>1.<strong>POST 方法主要用于向指定的资源提交数据。</strong>服务器端会获取这些数据并处理，然后进行回应。</p>
<blockquote>
<p>也就是说，POST 请求的操作是有损害(destructive)的，在发出请求的同时会有数据传送到服务器端，你（客户端）会对服务器端的资源进行更改。</p>
</blockquote>
<p>2.<strong>POST 请求的查询字符串（键值对）是在该请求的 HTTP 消息主体(request body)中发送的</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">POST /test/demo_form.asp HTTP/1.1</div><div class="line">Host: w3schools.com</div><div class="line">name1=value1&amp;name2=value2</div></pre></td></tr></table></figure>
<blockquote>
<p>正因如此，POST 请求相对 GET 请求在数据传输方面更加安全。（注意：此 <em>安全</em> 区别于上文提到的 GET 方法的安全性）</p>
</blockquote>
<p>3.<strong>POST 方法传输的数据长度没有限制。</strong></p>
<blockquote>
<p>在 HTTP 规范中，没有对 POST 请求传输的数据长度进行限制，而 POST 方法不依赖 URL ，所以没有限制。</p>
</blockquote>
<p>4.<strong>POST 请求不会被浏览器缓存。</strong></p>
<blockquote>
<p>如果你想，也可以通过手动设置的方法让浏览器进行缓存，不过通常不会这样做。</p>
</blockquote>
<p>5.<strong>POST 请求不会被保存在浏览器历史记录中，因此也无法被收藏为书签。</strong></p>
<p>6.<strong>POST 方法传输的数据对格式没有要求，比如，它允许是二进制数据。</strong></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上就是笔者对于 HTTP 协议中 GET 方法与 POST 方法二者区别的理解。若在以后学习过程中有新的发现或理解，笔者会及时进行更新。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE&quot; title=&quot;HyperText Transfer Protocol&quot;&gt;HTTP（超文本传输协议)&lt;/a&gt; 是目前互联网上应用最为广泛的一种 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE&quot;&gt;网络协议&lt;/a&gt; ，Web 网络中 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%AE%A2%E6%88%B7%E7%AB%AF&quot;&gt;客户端(Client)&lt;/a&gt; 到 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8&quot;&gt;服务器端(Server)&lt;/a&gt; 的通信就是建立在 HTTP 协议上。&lt;/p&gt;
&lt;img src=&quot;/2016/10/19/get-vs-post/request.png&quot; alt=&quot;Communication between Client and Server.&quot; title=&quot;Communication between Client and Server.&quot;&gt;
&lt;p&gt;HTTP 定义了几种客户端向服务器端发出请求的方法，如 GET、POST、HEAD、DELETE、OPTIONS、TRACE、CONNECT 等。但最常用的还是 GET 与 POST 方法，这两个方法之间的区别也是很多互联网公司面试官喜欢问的问题，下面笔者就来简单谈谈。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://songziming.com.cn/categories/JavaScript/"/>
    
    
      <category term="HTTP" scheme="http://songziming.com.cn/tags/HTTP/"/>
    
      <category term="GET" scheme="http://songziming.com.cn/tags/GET/"/>
    
      <category term="POST" scheme="http://songziming.com.cn/tags/POST/"/>
    
  </entry>
  
  <entry>
    <title>如何搭建个人博客（GitHub Pages + Hexo + 域名绑定）</title>
    <link href="http://songziming.com.cn/2016/10/02/how-to-set-up-blog/"/>
    <id>http://songziming.com.cn/2016/10/02/how-to-set-up-blog/</id>
    <published>2016-10-02T06:21:27.000Z</published>
    <updated>2017-04-13T04:53:15.049Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自己搭建一个独立博客似乎是一件很<em>极(zhuang)客(bi)</em>的事情，笔者觉得很好玩，所以抱着试试的态度搭建了本博客，请各位看官轻拍。</p>
<p>本文记载了笔者在Windows下一步步搭建博客并绑定域名的过程。搭建博客主要用了Hexo与GitHub Pages，域名绑定不是必须，读者可自行取舍。在Mac下搭建博客的步骤也是一样的。</p>
<a id="more"></a>
<h2 id="第一步，Hexo"><a href="#第一步，Hexo" class="headerlink" title="第一步，Hexo"></a>第一步，Hexo</h2><p><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="external">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。在安装Hexo之前，需要先安装Node.js以及Git。</p>
<h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>到Node.js的 <a href="https://nodejs.org/zh-cn/" target="_blank" rel="external">官网</a> 下载适合自己电脑系统的版本进行安装即可，推荐更稳定的LTS版本。</p>
<blockquote>
<p>笔者选择的是LTS的<code>.msi</code>文件进行安装（Windows 64-bit）。</p>
</blockquote>
<h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><ul>
<li>Windows：下载并安装 <a href="https://git-scm.com/download/win" target="_blank" rel="external">Git</a></li>
<li>Mac：使用 <a href="http://mxcl.github.com/homebrew/" target="_blank" rel="external">Homebrew</a>, <a href="http://www.macports.org/" target="_blank" rel="external">MacPorts</a> 或下载 <a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="external">安装程序</a> 安装。</li>
<li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li>
<li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></li>
</ul>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>Node.js和Hexo安装完毕后，终于可以安装Hexo啦！</p>
<p>打开Git Bash，输入以下命令即可完成安装。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g hexo-cli</div></pre></td></tr></table></figure>
<h3 id="部署Hexo站点"><a href="#部署Hexo站点" class="headerlink" title="部署Hexo站点"></a>部署Hexo站点</h3><p>在Hexo完成安装之后还需要部署本地的博客站点。</p>
<blockquote>
<p>以笔者为例，笔者打算把博客站点放到D盘的Blog文件夹下。</p>
</blockquote>
<p>进入D盘根目录，新建Blog文件夹。然后在D盘空白处单击右键，</p>
<img src="/2016/10/02/how-to-set-up-blog/3.jpg" alt="Git Bash" title="Git Bash">
<p>选择Git Bash Here。然后输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo init B<span class="built_in">log</span></div><div class="line">$ <span class="built_in">cd</span> B<span class="built_in">log</span></div><div class="line">$ npm install</div></pre></td></tr></table></figure>
<p>到此，Hexo博客站点本地部署完成。然后在d:/Blog文件夹下用Git Bash执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo g  <span class="comment">#生成本地发布文件夹</span></div><div class="line">$ hexo s  <span class="comment">#开启服务</span></div></pre></td></tr></table></figure>
<p>会出现如下反馈：</p>
<img src="/2016/10/02/how-to-set-up-blog/4.jpg" alt="hexo service" title="hexo service">
<p>然后你就可以浏览器输入<code>localhost:4000</code>预览你的博客了。</p>
<blockquote>
<p>别高兴的太早，这只是在你本地跑起来了，接下来需要把博客部署到网上（也就是GitHub Pages上）。</p>
</blockquote>
<h2 id="第二步，GitHub-Pages"><a href="#第二步，GitHub-Pages" class="headerlink" title="第二步，GitHub Pages"></a>第二步，GitHub Pages</h2><p><a href="https://github.com/" target="_blank" rel="external">GitHub</a> 是世界上最大的代码存放网站和开源社区。而 <a href="https://pages.github.com/" target="_blank" rel="external">GitHub Pages</a> 可以被认为是用户编写的、托管在GitHub上的静态网页。免费又稳定，用它来放博客，再合适不过了。</p>
<img src="/2016/10/02/how-to-set-up-blog/1.jpg" alt="GitHub Pages" title="GitHub Pages">
<h3 id="创建GitHub-Pages"><a href="#创建GitHub-Pages" class="headerlink" title="创建GitHub Pages"></a>创建GitHub Pages</h3><p>你需要有一个GitHub账号，然后只要创建一个Repository（代码仓库）就行了。但这个仓库是有规则的，其名字格式必须为：<code>yourusername.github.io</code>。创建好之后，这个仓库就是你的GitHub Pages了。</p>
<img src="/2016/10/02/how-to-set-up-blog/2.jpg" alt="GitHub Pages" title="GitHub Pages">
<blockquote>
<p>仓库命名格式中的<code>yourusername</code>是你的GitHub用户名。笔者的GitHub用户名是szm1002，所以仓库命名为<code>szm1002.github.io</code>。</p>
</blockquote>
<h3 id="配置和使用GitHub"><a href="#配置和使用GitHub" class="headerlink" title="配置和使用GitHub"></a>配置和使用GitHub</h3><p>我们需要设置SSH keys来让本地Git项目与GitHub建立联系。</p>
<h4 id="配置SSH-Keys"><a href="#配置SSH-Keys" class="headerlink" title="配置SSH Keys"></a>配置SSH Keys</h4><p>首先生成一个新的SSH key：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa -C <span class="string">"szm1002@126.com"</span></div><div class="line">Generating public/private rsa key pair.</div><div class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/Users/your_user_directory/.ssh/id_rsa):</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，需要把<em>邮箱地址</em>替换成你自己的邮箱地址，且此处 <code>-C</code> 是大写。</p>
</blockquote>
<p>此时回车就好。</p>
<p>然后系统会要你输入密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。</p>
<blockquote>
<p>注意：输入密码的时候没有*字样的，你直接输入就可以了。</p>
</blockquote>
<p>在本机设置SSH key之后，需要添加到GitHub上，以完成SSH链接的设置。</p>
<ol>
<li>打开id_rsa.pub文件（在C盘中，但不同系统具体路径可能不同，可在C盘中搜索该文件获取），此文件内容为刚才生成的密钥。如果看不到这个文件，你需要设置显示隐藏文件。准确复制这个文件的内容，才能保证设置成功。</li>
<li>登陆GitHub，点击右上角的 Account Settings—&gt;SSH Public keys —&gt; add another public keys 。</li>
<li>把你本地生成的密钥复制到里面（key文本框中）， 点击 add key 就ok了。</li>
</ol>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>可以输入下面的命令，看看设置是否成功：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh -T git@github.com</div></pre></td></tr></table></figure>
<p>如果是下面的反馈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.</div><div class="line">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</div><div class="line">Are you sure you want to continue connecting (yes/no)?</div></pre></td></tr></table></figure>
<p>输入yes，然后会看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hi szm1002! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</div></pre></td></tr></table></figure>
<p>此时，你的PC已经与GitHub建立联系，但还需要设置你的用户信息。</p>
<h4 id="设置用户信息"><a href="#设置用户信息" class="headerlink" title="设置用户信息"></a>设置用户信息</h4><p>输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name <span class="string">"szm1002"</span></div><div class="line">$ git config --global user.email  <span class="string">"szm1002@126.com"</span></div></pre></td></tr></table></figure>
<p>现在，你的PC就成功通过SSH链接到了GitHub了。</p>
<h3 id="Hexo部署到GitHub-Pages"><a href="#Hexo部署到GitHub-Pages" class="headerlink" title="Hexo部署到GitHub Pages"></a>Hexo部署到GitHub Pages</h3><p>在之前你只是在本地把博客跑起来了，现在我们需要把它部署到GitHub Pages上。</p>
<p>在Git Bash中cd到你的站点（以笔者为例，是d:/Blog文件夹），或在站点中右键选择Git Bash Here。输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>
<p>然后以文本编辑器打开站点的_config.yml文件，并滚动到最下面添加如下配置信息（注意最下边有deploy和type字段，需要覆盖这两个字段）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: https://github.com/szm1002/szm1002.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure>
<blockquote>
<p>其中repo字段的值是你的GitHub Pages提交代码的git地址。（注意需要添加.git后缀）<br>由于_config.yml文件有严格的格式要求，在type, repo, branch字段前面需要有两个空格。</p>
</blockquote>
<p>然后你就可以用以下命令把博客发布到GitHub上了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo clean  <span class="comment">#清除缓存</span></div><div class="line">$ hexo g  <span class="comment">#生成本地发布文件夹</span></div><div class="line">$ hexo d  <span class="comment">#deploy到GitHub</span></div></pre></td></tr></table></figure>
<blockquote>
<p><code>hexo g</code> 与 <code>hexo d</code> 两条命令可合并写成 <code>hexo d -g</code> 。</p>
</blockquote>
<p><strong>至此，博客已经搭建完成。</strong>你可以通过<code>http://yourusername.github.io</code>来访问你的博客了！</p>
<blockquote>
<p>Hexo博客有很多定制的主题，若你不喜欢默认的主题landscape，可自行选择其他的。笔者使用的是 <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">NexT</a>。主题使用方法可以通过它的文档获取，在此不赘述。</p>
<p>附上 <a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">Hexo主题大全</a> 。</p>
</blockquote>
<h2 id="第三步，域名绑定（可选，非必需）"><a href="#第三步，域名绑定（可选，非必需）" class="headerlink" title="第三步，域名绑定（可选，非必需）"></a>第三步，域名绑定（可选，非必需）</h2><h3 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h3><p>笔者是在 <a href="https://wanwang.aliyun.com/" target="_blank" rel="external">万网</a> 购买的域名（<a href="http://songziming.com.cn">songziming.com.cn</a>)。也有很多人推荐去国外一个很出名评价很好的网站 <a href="https://sg.godaddy.com/zh/" target="_blank" rel="external">GoDaddy</a> 购买。关于如何购买域名以及实名认证等这里不赘述，很简单。</p>
<h3 id="域名与GitHub-Pages绑定"><a href="#域名与GitHub-Pages绑定" class="headerlink" title="域名与GitHub Pages绑定"></a>域名与GitHub Pages绑定</h3><p>如果在万网购买的域名，可以使用万网的DNS解析，请直接跳到给域名添加记录那一步。但万网的解析好像不是很稳定，所以笔者使用的是DNSPod解析。</p>
<p>首先，修改你域名的DNS地址为 <code>f1g1ns1.dnspod.net</code> 和 <code>f1g1ns2.dnspod.net</code> 。</p>
<img src="/2016/10/02/how-to-set-up-blog/5.jpg" alt="DNS" title="DNS">
<p>然后在你的本地站点目录里的source目录下添加一个CNAME文件，不带后缀，<strong>注意文件名要大写</strong>。</p>
<img src="/2016/10/02/how-to-set-up-blog/6.jpg" alt="CNAME" title="CNAME">
<p>以文本编辑器打开CNAME，里面添加你的域名信息（不加<code>http://</code>）。如：添加 <code>songziming.com.cn</code> 。</p>
<blockquote>
<p>完成之后需要deploy到GitHub上。（<code>hexo d -g</code> ）</p>
</blockquote>
<p>最后，注册 <a href="https://www.dnspod.cn/" target="_blank" rel="external">DNSPod</a>，并添加域名，添加记录。</p>
<img src="/2016/10/02/how-to-set-up-blog/7.jpg" alt="添加域名" title="添加域名">
<img src="/2016/10/02/how-to-set-up-blog/8.jpg" alt="添加记录" title="添加记录">
<p>添加记录时按照图中的记录添加即可。如果使用万网的DNS解析，无须添加记录类型是NS的那两条。</p>
<blockquote>
<p>在记录中，<code>192.30.252.153</code> 与 <code>192.30.252.153</code> 是Github Pages服务器指定的IP地址，访问该IP地址即表示访问Github Pages。<br>记录类型为CNAME，记录值是szm1002.github.io.。表示将<code>http://songziming.com.cn</code>这个主域名映射szm1002.github.io。这里需要注意，在记录值中.io后面还有一个小数点。<br>DNS解析可能需要一段时间才生效。</p>
</blockquote>
<p>把你的更改都deploy到GitHub上去（<code>hexo d -g</code>）。</p>
<p>现在，<strong>域名已经绑定好了</strong>。尽情使用你的博客吧！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;自己搭建一个独立博客似乎是一件很&lt;em&gt;极(zhuang)客(bi)&lt;/em&gt;的事情，笔者觉得很好玩，所以抱着试试的态度搭建了本博客，请各位看官轻拍。&lt;/p&gt;
&lt;p&gt;本文记载了笔者在Windows下一步步搭建博客并绑定域名的过程。搭建博客主要用了Hexo与GitHub Pages，域名绑定不是必须，读者可自行取舍。在Mac下搭建博客的步骤也是一样的。&lt;/p&gt;
    
    </summary>
    
      <category term="Other Notes" scheme="http://songziming.com.cn/categories/Other-Notes/"/>
    
    
      <category term="GitHub" scheme="http://songziming.com.cn/tags/GitHub/"/>
    
      <category term="Hexo" scheme="http://songziming.com.cn/tags/Hexo/"/>
    
      <category term="博客" scheme="http://songziming.com.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
