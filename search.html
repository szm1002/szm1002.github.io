<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[JavaScript 中的正则表达式]]></title>
      <url>http://songziming.com.cn/2016/12/02/RegExp-in-JavaScript/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="external">正则表达式（Regular Expression）</a> 是一个描述字符模式的对象，它被用来匹配字符串中的字符组合。 JavaScript 中的 String 类和 RegExp 类都定义了使用正则表达式的方法。</p>
<h2 id="正则表达式的定义"><a href="#正则表达式的定义" class="headerlink" title="正则表达式的定义"></a>正则表达式的定义</h2><p>JavaScript 中的正则表达式用 RegExp 对象表示，所以我们可以使用 RegExp() 构造函数来创建 RegExp 对象，不过在实际 使用中 RegExp 对象更多的是通过直接量语法来创建的。正则表达式直接量定义为包含在一对斜杠 <code>&quot;/&quot;</code> 之间的字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var expression1 = /pattern/flags;           //RegExp直接量</div><div class="line">var expression2 = new RegExp(&quot;pattern&quot;, &quot;flags&quot;);    //RegExp构造函数</div></pre></td></tr></table></figure>
<blockquote>
<p>flags 代表修饰符，本文稍后有详细介绍。</p>
</blockquote>
<a id="more"></a>
<h3 id="直接量字符"><a href="#直接量字符" class="headerlink" title="直接量字符"></a>直接量字符</h3><p>正则表达式中的所有字母和数字都是按照字面含义进行匹配的，但它也支持通过反斜线 <code>&quot;\&quot;</code> 转义的非字母的字符匹配，这些转义字符如下表所示：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>匹配</th>
</tr>
</thead>
<tbody>
<tr>
<td>字母和数字字符</td>
<td>自身</td>
</tr>
<tr>
<td>\o</td>
<td>NUL字符（\u0000）</td>
</tr>
<tr>
<td>\t</td>
<td>制表符（\u0009）</td>
</tr>
<tr>
<td>\n</td>
<td>换行符（\u000A）</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表符（\u000B）</td>
</tr>
<tr>
<td>\f</td>
<td>换页符（\u000C）</td>
</tr>
<tr>
<td>\r</td>
<td>回车符（\u000D）</td>
</tr>
<tr>
<td>\xnn</td>
<td>由十六进制数 nn 指定的拉丁字符，例如 \x0A 等价于 \n</td>
</tr>
<tr>
<td>\uxxxx</td>
<td>由十六进制数 xxxx 指定的 Unicode 字符，例如 \u0009 等价于 \t</td>
</tr>
<tr>
<td>\cX</td>
<td>控制字符 ^X，例如 \cJ 等价于换行符 \n</td>
</tr>
</tbody>
</table>
<h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><p>将直接量字符单独放进方括号内就组成了字符类，一个字符类可以匹配它所包含的任意字符。例如，正则表达式 <code>/[abc]/</code> 就和字母 <code>&quot;a&quot;, &quot;b&quot;, &quot;c&quot;</code> 中的任意一个都匹配。正则表达式的字符类也支持转义字符定义的特殊字符，如下表所示：</p>
<img src="/2016/12/02/RegExp-in-JavaScript/1.png" alt="字符类" title="字符类">
<h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><p>正则表达式中还有一些重复字符语法，如下表所示：</p>
<img src="/2016/12/02/RegExp-in-JavaScript/2.png" alt="重复" title="重复">
<p>举一些栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/\d&#123;2,4&#125;/     //匹配2~4个数字</div><div class="line">/\w&#123;3&#125;\d?/    //精确匹配三个单词字符和一个可选的数字</div><div class="line">/\s+java\s+/  //匹配前后带有一个或多个空格的字符串&quot;java&quot;</div><div class="line">/[^(]*/       //匹配一个或多个非左括号的字符</div></pre></td></tr></table></figure>
<h3 id="选择与分组"><a href="#选择与分组" class="headerlink" title="选择与分组"></a>选择与分组</h3><p>字符 <code>&quot;|&quot;</code> 用于分隔供选择的字符。例如， <code>/ab|cd|ef/</code> 可以匹配字符串 <code>&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;</code> ； <code>/\d{3}|[a-z]{4}/</code> 匹配三位数字或四个小写字母。</p>
<blockquote>
<p>注意，选择项的尝试匹配次序是从左到右，直到发现匹配项。如果左边的选择项匹配，就忽略右边的匹配项，即使它产生更好的匹配。例如，当 <code>/a|ab/</code> 匹配字符串 <code>&quot;ab&quot;</code> 时，它只能匹配第一个字符。</p>
</blockquote>
<p>正则表达式的圆括号作用是把单独的项组合成子表达式，还可以在完整的模式中定义子模式。例如，<code>/java(script)?/</code> 可以匹配字符串 <code>&quot;java&quot;</code> ，其后可以有 <code>&quot;script&quot;</code> 也可以没有。</p>
<h3 id="指定匹配位置"><a href="#指定匹配位置" class="headerlink" title="指定匹配位置"></a>指定匹配位置</h3><p>在正则表达式中，有一些锚字符，用来指定字符串中的特殊位置，如下表所示：</p>
<img src="/2016/12/02/RegExp-in-JavaScript/3.png" alt="特殊位置" title="特殊位置">
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>正则表达式还有3个修饰符，分别是 <code>&quot;i&quot;, &quot;g&quot;, &quot;m&quot;</code> 。它们放在字面量的 <code>&quot;/&quot;</code> 符号之外，是 RegExp() 构造函数的第二个参数。它们的含义如下表所示：</p>
<img src="/2016/12/02/RegExp-in-JavaScript/4.png" alt="修饰符" title="修饰符">
<h2 id="用于模式匹配的-String-方法"><a href="#用于模式匹配的-String-方法" class="headerlink" title="用于模式匹配的 String 方法"></a>用于模式匹配的 String 方法</h2><h3 id="search-方法"><a href="#search-方法" class="headerlink" title="search() 方法"></a>search() 方法</h3><p>search() 方法的参数是一个正则表达式，返回第一个与之匹配的子串的起始位置，若无匹配的子串，则返回 -1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;JavaScript&quot;.search(/script/i);          //将返回4</div></pre></td></tr></table></figure>
<p>若 search() 方法的参数不是正则表达式，则首先会通过 RegExp() 构造函数将它转换为正则表达式。</p>
<p>search() 方法不支持全局搜索，因为它会忽略正则表达式参数中的修饰符 <code>g</code> 。</p>
<h3 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace() 方法"></a>replace() 方法</h3><p>replace() 方法用以执行检索与替换操作，它的第一个参数是正则表达式，第二个参数是要替换的字符串。它支持全局替换，不会忽略 <code>g</code> 修饰符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">text.replace(/javascript/gi, &quot;JavaScript&quot;);      //将text中所有不区分大小写的javascript都替换为JavaScript</div></pre></td></tr></table></figure>
<p>若 replace() 方法第一个参数是字符串而不是正则表达式，则它会直接搜索这个字符串，不会像 search() 方法那样通过 RegExp() 构造函数转换为正则表达式。</p>
<h3 id="match-方法"><a href="#match-方法" class="headerlink" title="match() 方法"></a>match() 方法</h3><p>match() 方法是最常用的 String 正则表达式方法，它的参数是一个正则表达式（若不是正则表达式会通过 RegExp() 构造函数转换），返回的是一个由匹配结果组成的数组。</p>
<p>若参数的正则表达式设置了 <code>g</code> 修饰符，则该方法返回的是一个包含所有匹配结果的数组。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;1 plus 2 equals 3&quot;.match(/\d+/g);   //返回[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</div></pre></td></tr></table></figure>
<p>若参数的正则表达式没有设置 <code>g</code> 修饰符，它不会进行全局搜索，但也返回一个数组，数组第一个元素是匹配的字符串，余下的元素是正则表达式中用圆括号括起来的子表达式匹配的字符串。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var url = /(\w+):\/\/([\w.]+)/;</div><div class="line">var text = &quot;Visit my blog at http://songziming.com.cn&quot;;</div><div class="line">var result = text.match(url);</div><div class="line">/*  [&quot;http://songziming.com.cn&quot;,</div><div class="line">     &quot;http&quot;,</div><div class="line">     &quot;songziming.com.cn&quot;,</div><div class="line">     &quot;~szm&quot;</div><div class="line">    ]</div><div class="line">*/</div></pre></td></tr></table></figure>
<h3 id="split-方法"><a href="#split-方法" class="headerlink" title="split() 方法"></a>split() 方法</h3><p>split() 用来分隔字符串为数组，它的参数既能是一个字符串也能是一个正则表达式（字符串不会通过 RegExp() 构造函数转换为正则表达式）。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;123,456,789&quot;.split(&quot;,&quot;);   //返回[&quot;123&quot;, &quot;456&quot;, &quot;789&quot;]</div><div class="line">&quot;1, 2, 3, 4&quot;.split(/\s*,\s*/);  //返回[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;]</div></pre></td></tr></table></figure>
<h2 id="RegExp-对象"><a href="#RegExp-对象" class="headerlink" title="RegExp 对象"></a>RegExp 对象</h2><p>文章开头讲到过，正则表达式还能通过 RegExp() 构造函数创建，它带有两个参数，第一个参数是正则表达式的主体部分，第二个参数可选，是修饰符。不过需要注意的是，在主体部分，不论是字符串直接量还是正则表达式，都需要使用 “\” 字符作为转义字符的前缀，因此当给 RegExp() 传入一个字符串表述的正则表达式时，必须将 “\” 替换为 “\“ 。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var zipcode = new RegExp(&quot;\\d&#123;5&#125;&quot;, &quot;g&quot;);   //全局匹配字符串中的5个数字</div></pre></td></tr></table></figure>
<h3 id="RegExp-对象的属性"><a href="#RegExp-对象的属性" class="headerlink" title="RegExp 对象的属性"></a>RegExp 对象的属性</h3><p>每个 RegExp 对象都具有5个属性，如下图所示：</p>
<img src="/2016/12/02/RegExp-in-JavaScript/5.png" alt="RegExp对象属性" title="RegExp对象属性">
<p>其中，global, ignoreCase, multiline 都是只读的布尔值，source 是一个只读的字符串，lastIndex 是一个可读可写的整数。</p>
<h3 id="RegExp-对象的方法"><a href="#RegExp-对象的方法" class="headerlink" title="RegExp 对象的方法"></a>RegExp 对象的方法</h3><h4 id="exec-方法"><a href="#exec-方法" class="headerlink" title="exec() 方法"></a>exec() 方法</h4><p>exec() 是 RegExp 对象最主要的模式匹配方法，它与 String 的 match() 方法非常相似。</p>
<p>exec() 方法的参数是一个字符串，它执行对这个字符串的匹配搜索。如果没有找到任何匹配，就返回 null；如果找到了一个匹配，它将返回一个数组，就像 match() 方法为非全局检索返回的数组一样。数组第一个元素与正则表达式匹配的字符串，余下的元素是与圆括号内的子表达式匹配的子串。返回的数组还包括了 index 与 input 两个属性，index 属性包含了发生匹配的字符位置，input 属性引用的是正在检索的字符串。</p>
<p>不管正则表达式是否具有g修饰符，exec() 方法都返回一样的数组。当同一个正则表达式第二次调用 exec() 方法时，将从 lastIndex 的位置开始检索。若 exec() 没有发现任何匹配结果，则将 lastIndex 重置为0。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var pattern = /Java/g;</div><div class="line">var text = &quot;JavaScript is more fun than Java!&quot;;</div><div class="line">var result;</div><div class="line">while((result = pattern.exec(text)) !== null) &#123;</div><div class="line">     alert(&quot;Matched &apos;&quot; + result[0] + &quot;&apos;&quot; +</div><div class="line">          &quot; at position &quot; + result.index +</div><div class="line">          &quot;; next search begins at &quot; + pattern.lastIndex);</div></pre></td></tr></table></figure>
<h4 id="test-方法"><a href="#test-方法" class="headerlink" title="test() 方法"></a>test() 方法</h4><p>test() 方法的参数是一个字符串，返回一个指示是否匹配的布尔值。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var pattern = /java/i;</div><div class="line">pattern.test(&quot;JavaScript&quot;);    //返回true</div></pre></td></tr></table></figure>
<p>调用 test() 与 exec() 等价。当一个全局正则表达式调用 test() 时，它会从 lastIndex 的位置开始检索，若找到了匹配结果，那么它就会设置 lastIndex 为当前匹配子串的结束位置。</p>
<blockquote>
<p>由于这个特性的存在，如果让一个带有 <code>g</code> 修饰符的正则表达式对多个字符串执行 exec() 或 test() 时，要么在每个字符串中找出所有的匹配以便将 lastIndex 自动重置为 0，要么需要手动重置 lastIndex 为 0。否则，下一次对新字符串进行检索时，起始位置可能就不是字符串的开始位置了。</p>
<p>在 ECMAScript 5 中，正则表达式直接量每次计算都会创建一个新的 RegExp 对象，因此每次对新字符串检索时 lastIndex 都是0。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP 中单引号与双引号的区别]]></title>
      <url>http://songziming.com.cn/2016/11/06/php-quote-md/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>应该大部分人都知道，在 C、 C++、 Java 等语言中，单引号引用的是单个字符，双引号引用的是一个字符串。笔者之前接触 JavaScript 比较多，在 JavaScript 中单双引号是没有区别的，都可用于引用 string 类型的变量（ <em>在 JSON 中，字符串必须加双引号，单引号会导致语法错误</em> ）。但笔者最近才发现，在 PHP 中单双引号的区别与这些语言都不一样，以下谨作为记录。</p>
<h2 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h2><p>在 PHP 中，用单引号（’）把一个字符串包围起来，代表引用的仅仅是这个字符串本身。也就是说变量 <code>$test</code> 以及转义序列 <code>\n</code> 或者 <code>\r</code> 等并不代表任何含义，就单纯是这几个字符串本身。举几个简单栗子如下：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$test = &apos;data&apos;;</div><div class="line">echo &apos;$test is a variable.&apos;;        //输出 $test is a variable.</div><div class="line">echo &apos;$test is a variable.\n&apos;;      //输出 $test is a variable.\n</div></pre></td></tr></table></figure>
<h2 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h2><p>与上述所说的单引号不同，PHP中的双引号（”）则会对变量、转义字符等特殊字符进行解析。举几个栗子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$test = &apos;data&apos;;</div><div class="line">echo &quot;$test is a variable.&quot;;        //输出 data is a variable.</div><div class="line">echo &quot;$test is a variable.\n&quot;;      //输出 data is a variable.（同时换行）</div></pre></td></tr></table></figure>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>总结成一句话就是，<strong> PHP 里的单引号把内容当成纯文本，不经过服务器翻译，而双引号里面的内容则会经过服务器处理</strong>。由于存在这个区别，在PHP中使用引号时结合点操作符（.）操作字符串就可以非常灵活了。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$name = &apos;szm&apos;;</div><div class="line">echo &apos;My name is &apos;.$name.&apos;.&apos;;</div><div class="line">echo &quot;My name is $name.&quot;;</div><div class="line"></div><div class="line">//两个输出都是 My name is szm.</div></pre></td></tr></table></figure>
<p>怎么样，是不是觉得PHP的这个特性很神奇？</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript中的回调函数]]></title>
      <url>http://songziming.com.cn/2016/10/30/callback/</url>
      <content type="html"><![CDATA[<h2 id="什么是回调函数"><a href="#什么是回调函数" class="headerlink" title="什么是回调函数"></a>什么是回调函数</h2><p><a href="http://https://zh.wikipedia.org/wiki/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0" target="_blank" rel="external">回调函数（Callback）</a> 是一段可执行的代码段（通常包装成一个函数），它会作为一个参数传递给其他的代码（通常也是一个函数）。回调函数会等待父函数执行完毕后立即执行，而与此同时，其他函数的调用不会受到阻塞。</p>
<blockquote>
<p>A callback is a function that is passed as an argument to another function and is executed after its parent function has completed. Callbacks are special because they patiently wait to execute until their parent finishes. Meanwhile, the browser can be executing other functions or doing all sorts of other work.</p>
<p>— <a href="http://learn.jquery.com/" target="_blank" rel="external">jQuery</a> 官网</p>
</blockquote>
<p>打个比方，你到一个商店买东西，不巧你要的东西没货了，你会怎么办呢？</p>
<ol>
<li>每天去一趟商店，看东西到货了没</li>
<li>你给店员留了个电话，让他等东西到货后马上给你打电话</li>
</ol>
<p>前者是轮询，后者就是回调。</p>
<p>在这个回调机制里，你的电话号码就是回调函数，你把电话留给店员叫传递回调函数，东西到货叫做触发回调关联的事件，店员给你打电话就是调用回调函数。</p>
<a id="more"></a>
<h2 id="回调函数怎么用"><a href="#回调函数怎么用" class="headerlink" title="回调函数怎么用"></a>回调函数怎么用</h2><p>上面已经提到，JavaScript 中的回调函数一般都是作为参数传递给另外一个函数。下面分回调函数有没有参数两种情况分别说明如何传递它给父函数。</p>
<h3 id="没有参数的回调函数"><a href="#没有参数的回调函数" class="headerlink" title="没有参数的回调函数"></a>没有参数的回调函数</h3><p>如果回调函数没有参数，那么你可以这么传递给父函数：</p>
<pre><code>$.get( &quot;mypage.html&quot;, myCallBack );
</code></pre><p>当 <code>$.get()</code> 函数请求 <code>mypage.html</code> 完毕后，浏览器就会执行 <code>myCallBack()</code> 函数。</p>
<blockquote>
<p>注意，第二个参数就是函数名形式传递给父函数，不要把它写成了字符串形式，即不能加引号。</p>
</blockquote>
<h3 id="带有参数的回调函数"><a href="#带有参数的回调函数" class="headerlink" title="带有参数的回调函数"></a>带有参数的回调函数</h3><p>如果回调函数带有参数，很多人第一反应会这么使用：</p>
<pre><code>$.get( &quot;mypage.html&quot;, myCallBack( param1, param2 ) );   //Wrong!!!
</code></pre><p>这就大错特错啦！</p>
<p>因为这行代码会先执行 <code>myCallBack( param1, param2 )</code> 函数，然后把这个 <strong>函数的返回值</strong> 作为参数传递给 <code>$.get()</code> 。如果你确实想这么做，那当然是可以的。</p>
<p>但如果你是想把带有参数的 <code>myCallBack()</code> 作为回调函数使用，你就必须使用 <em>匿名函数</em> 把它包装起来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$.get( &quot;mypage.html&quot;, function() &#123;</div><div class="line"> </div><div class="line">    myCallBack( param1, param2 );</div><div class="line"> </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>这个匿名函数只做一件事，就是调用带有参数 <code>param1</code> 与 <code>param2</code> 的函数 <code>myCallBack()</code> 。</p>
</blockquote>
<p>当 <code>$.get()</code> 函数请求 <code>mypage.html</code> 完毕后，浏览器就会执行这个匿名函数，也就相当于执行 <code>myCallBack( param1, param2 )</code> 。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在 JavaScript 中回调函数几乎无处不在。回调本质上是一种设计模式，这种机制为编程提供了非常大的灵活性。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[简单谈谈 GET 与 POST 的区别]]></title>
      <url>http://songziming.com.cn/2016/10/19/get-vs-post/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" title="HyperText Transfer Protocol" target="_blank" rel="external">HTTP（超文本传输协议)</a> 是目前互联网上应用最为广泛的一种 <a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="external">网络协议</a> ，Web 网络中 <a href="https://zh.wikipedia.org/wiki/%E5%AE%A2%E6%88%B7%E7%AB%AF" target="_blank" rel="external">客户端(Client)</a> 到 <a href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="external">服务器端(Server)</a> 的通信就是建立在 HTTP 协议上。</p>
<img src="/2016/10/19/get-vs-post/request.png" alt="Communication between Client and Server." title="Communication between Client and Server.">
<p>HTTP 定义了几种客户端向服务器端发出请求的方法，如 GET、POST、HEAD、DELETE、OPTIONS、TRACE、CONNECT 等。但最常用的还是 GET 与 POST 方法，这两个方法之间的区别也是很多互联网公司面试官喜欢问的问题，下面笔者就来简单谈谈。</p>
<a id="more"></a>
<h2 id="GET-方法"><a href="#GET-方法" class="headerlink" title="GET 方法"></a>GET 方法</h2><p>1.<strong>GET 方法主要用于对服务器资源的获取。</strong>根据<a href="https://www.w3.org/Protocols/rfc2616/rfc2616.txt" target="_blank" rel="external"> HTTP 规范</a> ，它应该是 <strong>安全</strong> 的和 <a href="https://zh.wikipedia.org/wiki/%E5%86%AA%E7%AD%89" target="_blank" rel="external"><strong>幂等</strong></a> 的。</p>
<blockquote>
<p><em>安全</em> 指的是它的操作应该是无损害(non-destructive)的。通过 GET 方法，你（客户端）仅仅是从服务器端<code>获取</code>信息，而不会增加、修改数据，不会更改服务器上的资源。</p>
<p><em>幂等</em> 指的是客户端对同一 <a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6" target="_blank" rel="external">URL</a> 的多次请求应该返回同样的结果。</p>
</blockquote>
<p>2.<strong>GET 请求的查询字符串（键值对）是随 URL 一起发送的。</strong>URL 和传输数据以 <code>?</code> 分割，参数之间以 <code>&amp;</code> 相连，如 <code>/test/demo_form.asp?name1=value1&amp;name2=value2</code> 。</p>
<blockquote>
<p>正因如此，处理敏感数据（如密码）时，不应使用 GET 方法。</p>
</blockquote>
<p>3.<strong>GET 方法传输数据的长度是有限制的。</strong></p>
<blockquote>
<p>虽然在 HTTP 规范中，GET 请求数据的长度和 URL 长度都是无限制的，但实际上，大多数浏览器会限制 URL 长度(如 IE 浏览器限制在2083 bit）。因此 GET 请求传输数据的长度会有所限制。</p>
</blockquote>
<p>4.<strong>GET 请求可以被浏览器缓存。</strong></p>
<blockquote>
<p>因此，通过 GET 方法返回的数据可能是浏览器缓存的数据。</p>
</blockquote>
<p>5.<strong>GET 请求保留在浏览器历史记录中且可被收藏为书签。</strong></p>
<blockquote>
<p>笔者认为这一点也是 <em>查询字符串会随 URL 一起发送</em> 的缘故。</p>
</blockquote>
<p>6.<strong>GET 方法传输的数据只能是 ASCII 码格式，否则需要 URL 编码才能进行传输。</strong></p>
<blockquote>
<p>这也是由于 URL 的编码格式采用的是 ASCII 码。</p>
</blockquote>
<h2 id="POST-方法"><a href="#POST-方法" class="headerlink" title="POST 方法"></a>POST 方法</h2><p>1.<strong>POST 方法主要用于向指定的资源提交数据。</strong>服务器端会获取这些数据并处理，然后进行回应。</p>
<blockquote>
<p>也就是说，POST 请求的操作是有损害(destructive)的，在发出请求的同时会有数据传送到服务器端，你（客户端）会对服务器端的资源进行更改。</p>
</blockquote>
<p>2.<strong>POST 请求的查询字符串（键值对）是在该请求的 HTTP 消息主体(request body)中发送的</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">POST /test/demo_form.asp HTTP/1.1</div><div class="line">Host: w3schools.com</div><div class="line">name1=value1&amp;name2=value2</div></pre></td></tr></table></figure>
<blockquote>
<p>正因如此，POST 请求相对 GET 请求在数据传输方面更加安全。（注意：此 <em>安全</em> 区别于上文提到的 GET 方法的安全性）</p>
</blockquote>
<p>3.<strong>POST 方法传输的数据长度没有限制。</strong></p>
<blockquote>
<p>在 HTTP 规范中，没有对 POST 请求传输的数据长度进行限制，而 POST 方法不依赖 URL ，所以没有限制。</p>
</blockquote>
<p>4.<strong>POST 请求不会被浏览器缓存。</strong></p>
<blockquote>
<p>如果你想，也可以通过手动设置的方法让浏览器进行缓存，不过通常不会这样做。</p>
</blockquote>
<p>5.<strong>POST 请求不会被保存在浏览器历史记录中，因此也无法被收藏为书签。</strong></p>
<p>6.<strong>POST 方法传输的数据对格式没有要求，比如，它允许是二进制数据。</strong></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上就是笔者对于 HTTP 协议中 GET 方法与 POST 方法二者区别的理解。若在以后学习过程中有新的发现或理解，笔者会及时进行更新。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何搭建个人博客（GitHub Pages + Hexo + 域名绑定）]]></title>
      <url>http://songziming.com.cn/2016/10/02/how-to-set-up-blog/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自己搭建一个独立博客似乎是一件很<em>极(zhuang)客(bi)</em>的事情，笔者觉得很好玩，所以抱着试试的态度搭建了本博客，请各位看官轻拍。</p>
<p>本文记载了笔者在Windows下一步步搭建博客并绑定域名的过程。搭建博客主要用了Hexo与GitHub Pages，域名绑定不是必须，读者可自行取舍。在Mac下搭建博客的步骤也是一样的。</p>
<h2 id="第一步，Hexo"><a href="#第一步，Hexo" class="headerlink" title="第一步，Hexo"></a>第一步，Hexo</h2><p><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="external">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。在安装Hexo之前，需要先安装Node.js以及Git。</p>
<h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>到Node.js的 <a href="https://nodejs.org/zh-cn/" target="_blank" rel="external">官网</a> 下载适合自己电脑系统的版本进行安装即可，推荐更稳定的LTS版本。</p>
<blockquote>
<p>笔者选择的是LTS的<code>.msi</code>文件进行安装（Windows 64-bit）。</p>
</blockquote>
<a id="more"></a>
<h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><ul>
<li>Windows：下载并安装 <a href="https://git-scm.com/download/win" target="_blank" rel="external">Git</a></li>
<li>Mac：使用 <a href="http://mxcl.github.com/homebrew/" target="_blank" rel="external">Homebrew</a>, <a href="http://www.macports.org/" target="_blank" rel="external">MacPorts</a> 或下载 <a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="external">安装程序</a> 安装。</li>
<li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li>
<li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></li>
</ul>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>Node.js和Hexo安装完毕后，终于可以安装Hexo啦！</p>
<p>打开Git Bash，输入以下命令即可完成安装。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g hexo-cli</div></pre></td></tr></table></figure>
<h3 id="部署Hexo站点"><a href="#部署Hexo站点" class="headerlink" title="部署Hexo站点"></a>部署Hexo站点</h3><p>在Hexo完成安装之后还需要部署本地的博客站点。</p>
<blockquote>
<p>以笔者为例，笔者打算把博客站点放到D盘的Blog文件夹下。</p>
</blockquote>
<p>进入D盘根目录，新建Blog文件夹。然后在D盘空白处单击右键，</p>
<img src="/2016/10/02/how-to-set-up-blog/3.jpg" alt="Git Bash" title="Git Bash">
<p>选择Git Bash Here。然后输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo init B<span class="built_in">log</span></div><div class="line">$ <span class="built_in">cd</span> B<span class="built_in">log</span></div><div class="line">$ npm install</div></pre></td></tr></table></figure>
<p>到此，Hexo博客站点本地部署完成。然后在d:/Blog文件夹下用Git Bash执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo g  <span class="comment">#生成本地发布文件夹</span></div><div class="line">$ hexo s  <span class="comment">#开启服务</span></div></pre></td></tr></table></figure>
<p>会出现如下反馈：</p>
<img src="/2016/10/02/how-to-set-up-blog/4.jpg" alt="hexo service" title="hexo service">
<p>然后你就可以浏览器输入<code>localhost:4000</code>预览你的博客了。</p>
<blockquote>
<p>别高兴的太早，这只是在你本地跑起来了，接下来需要把博客部署到网上（也就是GitHub Pages上）。</p>
</blockquote>
<h2 id="第二步，GitHub-Pages"><a href="#第二步，GitHub-Pages" class="headerlink" title="第二步，GitHub Pages"></a>第二步，GitHub Pages</h2><p><a href="https://github.com/" target="_blank" rel="external">GitHub</a> 是世界上最大的代码存放网站和开源社区。而 <a href="https://pages.github.com/" target="_blank" rel="external">GitHub Pages</a> 可以被认为是用户编写的、托管在GitHub上的静态网页。免费又稳定，用它来放博客，再合适不过了。</p>
<img src="/2016/10/02/how-to-set-up-blog/1.jpg" alt="GitHub Pages" title="GitHub Pages">
<h3 id="创建GitHub-Pages"><a href="#创建GitHub-Pages" class="headerlink" title="创建GitHub Pages"></a>创建GitHub Pages</h3><p>你需要有一个GitHub账号，然后只要创建一个Repository（代码仓库）就行了。但这个仓库是有规则的，其名字格式必须为：<code>yourusername.github.io</code>。创建好之后，这个仓库就是你的GitHub Pages了。</p>
<img src="/2016/10/02/how-to-set-up-blog/2.jpg" alt="GitHub Pages" title="GitHub Pages">
<blockquote>
<p>仓库命名格式中的<code>yourusername</code>是你的GitHub用户名。笔者的GitHub用户名是szm1002，所以仓库命名为<code>szm1002.github.io</code>。</p>
</blockquote>
<h3 id="配置和使用GitHub"><a href="#配置和使用GitHub" class="headerlink" title="配置和使用GitHub"></a>配置和使用GitHub</h3><p>我们需要设置SSH keys来让本地Git项目与GitHub建立联系。</p>
<h4 id="配置SSH-Keys"><a href="#配置SSH-Keys" class="headerlink" title="配置SSH Keys"></a>配置SSH Keys</h4><p>首先生成一个新的SSH key：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa -C <span class="string">"szm1002@126.com"</span></div><div class="line">Generating public/private rsa key pair.</div><div class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/Users/your_user_directory/.ssh/id_rsa):</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，需要把<em>邮箱地址</em>替换成你自己的邮箱地址，且此处 <code>-C</code> 是大写。</p>
</blockquote>
<p>此时回车就好。</p>
<p>然后系统会要你输入密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。</p>
<blockquote>
<p>注意：输入密码的时候没有*字样的，你直接输入就可以了。</p>
</blockquote>
<p>在本机设置SSH key之后，需要添加到GitHub上，以完成SSH链接的设置。</p>
<ol>
<li>打开id_rsa.pub文件（在C盘中，但不同系统具体路径可能不同，可在C盘中搜索该文件获取），此文件内容为刚才生成的密钥。如果看不到这个文件，你需要设置显示隐藏文件。准确复制这个文件的内容，才能保证设置成功。</li>
<li>登陆GitHub，点击右上角的 Account Settings—&gt;SSH Public keys —&gt; add another public keys 。</li>
<li>把你本地生成的密钥复制到里面（key文本框中）， 点击 add key 就ok了。</li>
</ol>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>可以输入下面的命令，看看设置是否成功：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh -T git@github.com</div></pre></td></tr></table></figure>
<p>如果是下面的反馈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.</div><div class="line">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</div><div class="line">Are you sure you want to continue connecting (yes/no)?</div></pre></td></tr></table></figure>
<p>输入yes，然后会看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hi szm1002! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</div></pre></td></tr></table></figure>
<p>此时，你的PC已经与GitHub建立联系，但还需要设置你的用户信息。</p>
<h4 id="设置用户信息"><a href="#设置用户信息" class="headerlink" title="设置用户信息"></a>设置用户信息</h4><p>输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name <span class="string">"szm1002"</span></div><div class="line">$ git config --global user.email  <span class="string">"szm1002@126.com"</span></div></pre></td></tr></table></figure>
<p>现在，你的PC就成功通过SSH链接到了GitHub了。</p>
<h3 id="Hexo部署到GitHub-Pages"><a href="#Hexo部署到GitHub-Pages" class="headerlink" title="Hexo部署到GitHub Pages"></a>Hexo部署到GitHub Pages</h3><p>在之前你只是在本地把博客跑起来了，现在我们需要把它部署到GitHub Pages上。</p>
<p>在Git Bash中cd到你的站点（以笔者为例，是d:/Blog文件夹），或在站点中右键选择Git Bash Here。输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>
<p>然后以文本编辑器打开站点的_config.yml文件，并滚动到最下面添加如下配置信息（注意最下边有deploy和type字段，需要覆盖这两个字段）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: https://github.com/szm1002/szm1002.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure>
<blockquote>
<p>其中repo字段的值是你的GitHub Pages提交代码的git地址。（注意需要添加.git后缀）<br>由于_config.yml文件有严格的格式要求，在type, repo, branch字段前面需要有两个空格。</p>
</blockquote>
<p>然后你就可以用以下命令把博客发布到GitHub上了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo clean  <span class="comment">#清除缓存</span></div><div class="line">$ hexo g  <span class="comment">#生成本地发布文件夹</span></div><div class="line">$ hexo d  <span class="comment">#deploy到GitHub</span></div></pre></td></tr></table></figure>
<blockquote>
<p><code>hexo g</code> 与 <code>hexo d</code> 两条命令可合并写成 <code>hexo d -g</code> 。</p>
</blockquote>
<p><strong>至此，博客已经搭建完成。</strong>你可以通过<code>http://yourusername.github.io</code>来访问你的博客了！</p>
<blockquote>
<p>Hexo博客有很多定制的主题，若你不喜欢默认的主题landscape，可自行选择其他的。笔者使用的是 <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">NexT</a>。主题使用方法可以通过它的文档获取，在此不赘述。</p>
<p>附上 <a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">Hexo主题大全</a> 。</p>
</blockquote>
<h2 id="第三步，域名绑定（可选，非必需）"><a href="#第三步，域名绑定（可选，非必需）" class="headerlink" title="第三步，域名绑定（可选，非必需）"></a>第三步，域名绑定（可选，非必需）</h2><h3 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h3><p>笔者是在 <a href="https://wanwang.aliyun.com/" target="_blank" rel="external">万网</a> 购买的域名（<a href="http://songziming.com.cn">songziming.com.cn</a>)。也有很多人推荐去国外一个很出名评价很好的网站 <a href="https://sg.godaddy.com/zh/" target="_blank" rel="external">GoDaddy</a> 购买。关于如何购买域名以及实名认证等这里不赘述，很简单。</p>
<h3 id="域名与GitHub-Pages绑定"><a href="#域名与GitHub-Pages绑定" class="headerlink" title="域名与GitHub Pages绑定"></a>域名与GitHub Pages绑定</h3><p>如果在万网购买的域名，可以使用万网的DNS解析，请直接跳到给域名添加记录那一步。但万网的解析好像不是很稳定，所以笔者使用的是DNSPod解析。</p>
<p>首先，修改你域名的DNS地址为 <code>f1g1ns1.dnspod.net</code> 和 <code>f1g1ns2.dnspod.net</code> 。</p>
<img src="/2016/10/02/how-to-set-up-blog/5.jpg" alt="DNS" title="DNS">
<p>然后在你的本地站点目录里的source目录下添加一个CNAME文件，不带后缀，<strong>注意文件名要大写</strong>。</p>
<img src="/2016/10/02/how-to-set-up-blog/6.jpg" alt="CNAME" title="CNAME">
<p>以文本编辑器打开CNAME，里面添加你的域名信息（不加<code>http://</code>）。如：添加 <code>songziming.com.cn</code> 。</p>
<blockquote>
<p>完成之后需要deploy到GitHub上。（<code>hexo d -g</code> ）</p>
</blockquote>
<p>最后，注册 <a href="https://www.dnspod.cn/" target="_blank" rel="external">DNSPod</a>，并添加域名，添加记录。</p>
<img src="/2016/10/02/how-to-set-up-blog/7.jpg" alt="添加域名" title="添加域名">
<img src="/2016/10/02/how-to-set-up-blog/8.jpg" alt="添加记录" title="添加记录">
<p>添加记录时按照图中的记录添加即可。如果使用万网的DNS解析，无须添加记录类型是NS的那两条。</p>
<blockquote>
<p>在记录中，<code>192.30.252.153</code> 与 <code>192.30.252.153</code> 是Github Pages服务器指定的IP地址，访问该IP地址即表示访问Github Pages。<br>记录类型为CNAME，记录值是szm1002.github.io.。表示将<code>http://songziming.com.cn</code>这个主域名映射szm1002.github.io。这里需要注意，在记录值中.io后面还有一个小数点。<br>DNS解析可能需要一段时间才生效。</p>
</blockquote>
<p>把你的更改都deploy到GitHub上去（<code>hexo d -g</code>）。</p>
<p>现在，<strong>域名已经绑定好了</strong>。尽情使用你的博客吧！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://songziming.com.cn/2016/10/01/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<a id="more"></a>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
